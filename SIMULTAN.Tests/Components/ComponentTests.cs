using Microsoft.VisualStudio.TestTools.UnitTesting;
using SIMULTAN.Data;
using SIMULTAN.Data.Components;
using SIMULTAN.Data.Taxonomy;
using SIMULTAN.Data.Users;
using SIMULTAN.Tests.TestUtils;
using SIMULTAN.Tests.Util;
using System;
using System.IO;
using System.Linq;
using System.Windows.Media;

namespace SIMULTAN.Tests.Components
{
    [TestClass]
    public class ComponentTests : BaseProjectTest
    {
        private static readonly FileInfo accessProject = new FileInfo(@".\ComponentAccessTestsProject.simultan");
        private static readonly FileInfo componentProject = new FileInfo(@".\ComponentTests.simultan");

        private void CheckComponentProperties(SimComponent component, SimId id, string name, string description, Color color, SimComponentVisibility visibility,
            SimTaxonomyEntryReference slot, SimComponentContentSorting sorting, bool isAutoGenerated)
        {
            Assert.AreEqual(id, component.Id);
            Assert.AreEqual(name, component.Name);
            Assert.AreEqual(description, component.Description);
            Assert.AreEqual(color, component.ComponentColor);
            Assert.AreEqual(slot.Target, component.CurrentSlot.Target);
            Assert.AreEqual(visibility, component.Visibility);
            Assert.AreEqual(sorting, component.SortingType);
            Assert.AreEqual(false, component.IsAutomaticallyGenerated);
        }

        [TestMethod]
        public void Ctor()
        {
            SimComponent component = new SimComponent();

            Assert.AreEqual(SimId.Empty, component.Id);
            Assert.AreEqual(string.Empty, component.Name);
            Assert.AreEqual(string.Empty, component.Description);
            Assert.AreEqual(Color.FromArgb(255, 0, 255, 0), component.ComponentColor);
            // CurrentSlot is null using the empty constructor, needs to be set manually
            Assert.AreEqual(null, component.CurrentSlot);
            Assert.AreEqual(SimComponentVisibility.VisibleInProject, component.Visibility);
            Assert.AreEqual(SimComponentContentSorting.ByName, component.SortingType);
            Assert.AreEqual(false, component.IsAutomaticallyGenerated);

            Assert.AreEqual(0, component.Components.Count);
            Assert.AreEqual(0, component.Calculations.Count);
            Assert.AreEqual(0, component.Parameters.Count);
            Assert.AreEqual(0, component.ReferencedComponents.Count);
            Assert.AreEqual(0, component.ReferencedBy.Count);
            Assert.AreEqual(0, component.Instances.Count);
            Assert.AreEqual(0, component.CalculatorMappings.Count);
            Assert.AreEqual(0, component.MappedToBy.Count);
            Assert.AreEqual(0, component.ReferencedAssets.Count);

            //Access
            foreach (var role in Enum.GetValues(typeof(SimUserRole)).OfType<SimUserRole>())
            {
                var profile = component.AccessLocal[role];
                Assert.AreEqual(role, profile.Role);

                if (role != SimUserRole.ADMINISTRATOR)
                    Assert.AreEqual(SimComponentAccessPrivilege.None, profile.Access);
                else
                    Assert.AreEqual(SimComponentAccessPrivilege.Write | SimComponentAccessPrivilege.Read, profile.Access);
            }
        }

        [TestMethod]
        public void CtorCopy()
        {
            LoadProject(componentProject);

            var root = projectData.Components.First(x => x.Name == "Root");
            var child1 = root.Components.First(x => x.Component != null && x.Component.Name == "Child1").Component;
            var child2 = root.Components.First(x => x.Component != null && x.Component.Name == "Child2").Component;

            Assert.ThrowsException<ArgumentNullException>(() => { new SimComponent(null); });

            //Create copy
            var copy = new SimComponent(root);

            CheckComponentProperties(copy, SimId.Empty, root.Name, root.Description, root.ComponentColor, root.Visibility,
                root.CurrentSlot, root.SortingType, root.IsAutomaticallyGenerated);

            //Children
            Assert.AreEqual(3, copy.Components.Count);

            var copyChild1 = copy.Components.First(x => x.Component != null && x.Component.Name == "Child1").Component;
            CheckComponentProperties(copyChild1, SimId.Empty, child1.Name, child1.Description, child1.ComponentColor, child1.Visibility,
                child1.CurrentSlot, child1.SortingType, child1.IsAutomaticallyGenerated);

            var copyChild2 = copy.Components.First(x => x.Component != null && x.Component.Name == "Child2").Component;
            CheckComponentProperties(copyChild2, SimId.Empty, child2.Name, child2.Description, child2.ComponentColor, child2.Visibility,
                child2.CurrentSlot, child2.SortingType, child2.IsAutomaticallyGenerated);

            //Placeholder
            var placeholder = copy.Components.First(x => x.Component == null);
            var costTax = projectData.Taxonomies.GetDefaultSlot(SimDefaultSlotKeys.Cost);
            Assert.AreEqual(new SimSlot(costTax, "17"), placeholder.Slot);
        }

        [TestMethod]
        public void CtorCopyReferences()
        {
            LoadProject(componentProject);

            var root = projectData.Components.First(x => x.Name == "Root");
            var target = projectData.Components.First(x => x.Name == "Target");

            var copy = new SimComponent(root);
            var copychild1 = copy.Components.First(x => x.Component != null && x.Component.Name == "Child1").Component;
            var copychildchild1 = Enumerable.First<SimChildComponentEntry>(copychild1.Components, x => x.Component != null && x.Component.Name == "ChildChild1").Component;
            var copychildchild2 = Enumerable.First<SimChildComponentEntry>(copychild1.Components, x => x.Component != null && x.Component.Name == "ChildChild2").Component;
            var copychild2 = copy.Components.First(x => x.Component != null && x.Component.Name == "Child2").Component;
            var copychildchild3 = Enumerable.First<SimChildComponentEntry>(copychild2.Components, x => x.Component != null && x.Component.Name == "ChildChild3").Component;
            var copychildchild4 = Enumerable.First<SimChildComponentEntry>(copychild2.Components, x => x.Component != null && x.Component.Name == "ChildChild4").Component;

            Assert.AreEqual(0, copy.ReferencedComponents.Count);

            Assert.AreEqual(2, copychild1.ReferencedComponents.Count);
            //Internal reference
            var reference = copychild1.ReferencedComponents.First(x => x.Target != null);
            Assert.AreEqual(new SimSlot(projectData.Taxonomies.GetDefaultSlot(SimDefaultSlotKeys.Undefined), "5"), reference.Slot);
            Assert.AreEqual(copychildchild3, reference.Target);
            //Placeholder
            reference = copychild1.ReferencedComponents.First(x => x.Target == null);
            Assert.AreEqual(new SimSlot(projectData.Taxonomies.GetDefaultSlot(SimDefaultSlotKeys.Joint), "8"), reference.Slot);
            Assert.AreEqual(null, reference.Target);

            Assert.AreEqual(2, copychildchild1.ReferencedComponents.Count);
            //Internal reference
            reference = copychildchild1.ReferencedComponents.First(x => x.Slot.SlotExtension == "0");
            Assert.AreEqual(new SimSlot(projectData.Taxonomies.GetDefaultSlot(SimDefaultSlotKeys.Undefined), "0"), reference.Slot);
            Assert.AreEqual(copychildchild4, reference.Target);
            //External reference
            reference = copychildchild1.ReferencedComponents.First(x => x.Slot.SlotExtension == "1");
            Assert.AreEqual(new SimSlot(projectData.Taxonomies.GetDefaultSlot(SimDefaultSlotKeys.Undefined), "1"), reference.Slot);
            Assert.AreEqual(target, reference.Target);
        }

        [TestMethod]
        public void CtorCopyDoubleParameter()
        {
            LoadProject(componentProject);

            var root = projectData.Components.First(x => x.Name == "Root");
            var aParam = root.Parameters.OfType<SimDoubleParameter>().First(x => x.NameTaxonomyEntry.Name == "a");

            var copy = new SimComponent(root);
            var copyaParam = copy.Parameters.OfType<SimDoubleParameter>().First(x => x.NameTaxonomyEntry.Name == "a");

            Assert.AreEqual(aParam.NameTaxonomyEntry.Name, copyaParam.NameTaxonomyEntry.Name);
            Assert.AreEqual(SimId.Empty, copyaParam.Id);
            Assert.AreEqual(aParam.Propagation, copyaParam.Propagation);
            Assert.AreEqual(aParam.Value, copyaParam.Value);
        }
        [TestMethod]
        public void CtorCopyIntParameter()
        {
            LoadProject(componentProject);

            var root = projectData.Components.First(x => x.Name == "Root");
            var aParam = root.Parameters.OfType<SimIntegerParameter>().First(x => x.NameTaxonomyEntry.Name == "int");

            var copy = new SimComponent(root);
            var copyaParam = copy.Parameters.OfType<SimIntegerParameter>().First(x => x.NameTaxonomyEntry.Name == "int");

            Assert.AreEqual(aParam.NameTaxonomyEntry.Name, copyaParam.NameTaxonomyEntry.Name);
            Assert.AreEqual(SimId.Empty, copyaParam.Id);
            Assert.AreEqual(aParam.Propagation, copyaParam.Propagation);
            Assert.AreEqual(aParam.Value, copyaParam.Value);
        }
        [TestMethod]
        public void CtorCopySringParameter()
        {
            LoadProject(componentProject);

            var root = projectData.Components.First(x => x.Name == "Root");
            var aParam = root.Parameters.OfType<SimStringParameter>().First(x => x.NameTaxonomyEntry.Name == "string");

            var copy = new SimComponent(root);
            var copyaParam = copy.Parameters.OfType<SimStringParameter>().First(x => x.NameTaxonomyEntry.Name == "string");

            Assert.AreEqual(aParam.NameTaxonomyEntry.Name, copyaParam.NameTaxonomyEntry.Name);
            Assert.AreEqual(SimId.Empty, copyaParam.Id);
            Assert.AreEqual(aParam.Propagation, copyaParam.Propagation);
            Assert.AreEqual(aParam.Value, copyaParam.Value);
        }
        [TestMethod]
        public void CtorCopyBoolParameter()
        {
            LoadProject(componentProject);

            var root = projectData.Components.First(x => x.Name == "Root");
            var aParam = root.Parameters.OfType<SimBoolParameter>().First(x => x.NameTaxonomyEntry.Name == "bool");

            var copy = new SimComponent(root);
            var copyaParam = copy.Parameters.OfType<SimBoolParameter>().First(x => x.NameTaxonomyEntry.Name == "bool");

            Assert.AreEqual(aParam.NameTaxonomyEntry.Name, copyaParam.NameTaxonomyEntry.Name);
            Assert.AreEqual(SimId.Empty, copyaParam.Id);
            Assert.AreEqual(aParam.Propagation, copyaParam.Propagation);
            Assert.AreEqual(aParam.Value, copyaParam.Value);
        }
        [TestMethod]
        public void CtorCopyEnumParameter()
        {
            LoadProject(componentProject);

            var root = projectData.Components.First(x => x.Name == "Root");
            var aParam = root.Parameters.OfType<SimEnumParameter>().First(x => x.NameTaxonomyEntry.Name == "enum");

            var copy = new SimComponent(root);
            var copyaParam = copy.Parameters.OfType<SimEnumParameter>().First(x => x.NameTaxonomyEntry.Name == "enum");

            Assert.AreEqual(aParam.NameTaxonomyEntry.Name, copyaParam.NameTaxonomyEntry.Name);
            Assert.AreEqual(SimId.Empty, copyaParam.Id);
            Assert.AreEqual(aParam.Propagation, copyaParam.Propagation);
            Assert.IsTrue(aParam.Value.Target == copyaParam.Value.Target);

            Assert.IsFalse(object.ReferenceEquals(aParam.Value, copyaParam.Value));

        }

        [TestMethod]
        public void CtorCopyCalculation()
        {
            LoadProject(componentProject);

            var root = projectData.Components.First(x => x.Name == "Root");

            var copy = new SimComponent(root);

            var copyCalc = copy.Calculations.First();

            Assert.AreEqual(copy, copyCalc.InputParams["a"].Component);
            Assert.AreEqual(copy, copyCalc.InputParams["b"].Component.Parent);
            Assert.AreEqual(copy, copyCalc.ReturnParams["out1"].Component);
            Assert.AreEqual(copy, copyCalc.ReturnParams["out01"].Component.Parent);
        }

        #region Properties

        [TestMethod]
        public void PropertyName()
        {
            SimComponent component = new SimComponent();
            PropertyTestUtils.CheckProperty(component, nameof(SimComponent.Name), "somename");
        }

        [TestMethod]
        public void PropertyDescription()
        {
            SimComponent component = new SimComponent();
            PropertyTestUtils.CheckProperty(component, nameof(SimComponent.Description), "somenewdescription");
        }

        [TestMethod]
        public void PropertyComponentColor()
        {
            SimComponent component = new SimComponent();
            PropertyTestUtils.CheckProperty(component, nameof(SimComponent.ComponentColor), Colors.Pink);
        }

        [TestMethod]
        public void PropertyCurrentSlot()
        {
            SimComponent component = new SimComponent();
            var jointSlot = TaxonomyUtils.GetDefaultSlot(SimDefaultSlotKeys.Joint);
            PropertyTestUtils.CheckProperty(component, nameof(SimComponent.CurrentSlot), new SimTaxonomyEntryReference(jointSlot));
        }

        [TestMethod]
        public void PropertyVisibility()
        {
            SimComponent component = new SimComponent();
            PropertyTestUtils.CheckProperty(component, nameof(SimComponent.Visibility), SimComponentVisibility.AlwaysVisible);
        }

        [TestMethod]
        public void PropertySortingType()
        {
            SimComponent component = new SimComponent();
            PropertyTestUtils.CheckProperty(component, nameof(SimComponent.SortingType), SimComponentContentSorting.BySlot);
        }

        [TestMethod]
        public void PropertyIsAutomaticallyGenerated()
        {
            SimComponent component = new SimComponent();
            PropertyTestUtils.CheckProperty(component, nameof(SimComponent.IsAutomaticallyGenerated), true);
        }

        [TestMethod]
        public void PropertyInstanceType()
        {
            SimComponent component = new SimComponent();
            PropertyTestUtils.CheckProperty(component, nameof(SimComponent.InstanceType), SimInstanceType.GeometricVolume);
        }

        #endregion

        #region Property Access

        private void CheckComponentPropertyAccess<T>(string prop, T value)
        {
            LoadProject(accessProject, "bph", "bph");
            var bphComponent = projectData.Components.First(x => x.Name == "BPHRoot");
            var archComponent = projectData.Components.First(x => x.Name == "ArchRoot");

            PropertyTestUtils.CheckPropertyAccess(bphComponent, archComponent, prop, value);
        }


        [TestMethod]
        public void PropertyNameAccess()
        {
            CheckComponentPropertyAccess(nameof(SimComponent.Name), "newName");
        }

        [TestMethod]
        public void PropertyDescriptionAccess()
        {
            CheckComponentPropertyAccess(nameof(SimComponent.Description), "newDescription");
        }

        [TestMethod]
        public void PropertyComponentColorAccess()
        {
            CheckComponentPropertyAccess(nameof(SimComponent.ComponentColor), Colors.Pink);
        }

        [TestMethod]
        public void PropertyCurrentSlotAccess()
        {
            var jointSlot = TaxonomyUtils.GetDefaultSlot(SimDefaultSlotKeys.Joint);
            CheckComponentPropertyAccess(nameof(SimComponent.CurrentSlot), new SimTaxonomyEntryReference(jointSlot));
        }

        [TestMethod]
        public void PropertyVisibilityAccess()
        {
            CheckComponentPropertyAccess(nameof(SimComponent.Visibility), SimComponentVisibility.AlwaysVisible);
        }

        [TestMethod]
        public void PropertySortingTypeAccess()
        {
            CheckComponentPropertyAccess(nameof(SimComponent.SortingType), SimComponentContentSorting.BySlot);
        }

        [TestMethod]
        public void PropertyIsAutomaticallyGeneratedAccess()
        {
            CheckComponentPropertyAccess(nameof(SimComponent.IsAutomaticallyGenerated), true);
        }

        [TestMethod]
        public void PropertyInstanceTypeAccess()
        {
            CheckComponentPropertyAccess(nameof(SimComponent.InstanceType), SimInstanceType.GeometricVolume);
        }

        #endregion

        #region Property Changes

        private void CheckComponentPropertyChanges<T>(string prop, T value)
        {
            //Setup
            LoadProject(accessProject, "bph", "bph");

            var bphComponent = projectData.Components.First(x => x.Name == "BPHRoot");

            PropertyTestUtils.CheckPropertyChanges(bphComponent, prop, value, SimUserRole.BUILDING_PHYSICS, bphComponent, projectData.Components);
        }


        [TestMethod]
        public void PropertyNameChanges()
        {
            CheckComponentPropertyChanges(nameof(SimComponent.Name), "somerandomname");
        }

        [TestMethod]
        public void PropertyDescriptionChanges()
        {
            CheckComponentPropertyChanges(nameof(SimComponent.Description), "somerandomdescription");
        }

        [TestMethod]
        public void PropertyComponentColorChanges()
        {
            CheckComponentPropertyChanges(nameof(SimComponent.ComponentColor), Colors.Pink);
        }

        [TestMethod]
        public void PropertyCurrentSlotChanges()
        {
            var jointSlot = TaxonomyUtils.GetDefaultSlot(SimDefaultSlotKeys.Joint);
            CheckComponentPropertyChanges(nameof(SimComponent.CurrentSlot), new SimTaxonomyEntryReference(jointSlot));
        }

        [TestMethod]
        public void PropertyVisibilityChanges()
        {
            CheckComponentPropertyChanges(nameof(SimComponent.Visibility), SimComponentVisibility.AlwaysVisible);
        }

        [TestMethod]
        public void PropertySortingTypeChanges()
        {
            CheckComponentPropertyChanges(nameof(SimComponent.SortingType), SimComponentContentSorting.BySlot);
        }

        [TestMethod]
        public void PropertyIsAutomaticallyGeneratedChanges()
        {
            CheckComponentPropertyChanges(nameof(SimComponent.IsAutomaticallyGenerated), true);
        }

        [TestMethod]
        public void PropertyInstanceTypeChanges()
        {
            CheckComponentPropertyChanges(nameof(SimComponent.InstanceType), SimInstanceType.GeometricVolume);
        }

        [TestMethod]
        public void SetCurrentSlotToUndefinedIfDeleted()
        {
            LoadProject(componentProject);

            var taxonomy = new SimTaxonomy("TEST");
            projectData.Taxonomies.Add(taxonomy);
            var entry = new SimTaxonomyEntry("key", "new slot");
            taxonomy.Entries.Add(entry);

            var undefinedEntry = projectData.Taxonomies.GetDefaultSlot(SimDefaultSlotKeys.Undefined);

            var component = projectData.Components.First(x => x.Name == "Root");
            component.CurrentSlot = new SimTaxonomyEntryReference(entry);

            Assert.AreEqual(entry, component.CurrentSlot.Target);

            // delete entry
            taxonomy.Entries.Remove(entry);

            Assert.AreNotEqual(entry, component.CurrentSlot.Target);
            Assert.AreEqual(undefinedEntry, component.CurrentSlot.Target);
        }

        private WeakReference SetCurrentSlotToUndefinedIfDeletedMemoryLeak_Action()
        {
            var taxonomy = new SimTaxonomy("TEST");
            projectData.Taxonomies.Add(taxonomy);
            var entry = new SimTaxonomyEntry("key", "new slot");
            taxonomy.Entries.Add(entry);

            var undefinedEntry = projectData.Taxonomies.GetDefaultSlot(SimDefaultSlotKeys.Undefined);

            var component = projectData.Components.First(x => x.Name == "Root");
            component.CurrentSlot = new SimTaxonomyEntryReference(entry);

            var wref = new WeakReference(entry);
            Assert.IsTrue(wref.IsAlive);

            // delete entry
            taxonomy.Entries.Remove(entry);
            return wref;
        }
        [TestMethod]
        public void SetCurrentSlotToUndefinedIfDeletedMemoryLeak()
        {
            LoadProject(componentProject);

            var wref = SetCurrentSlotToUndefinedIfDeletedMemoryLeak_Action();

            GC.Collect();
            GC.WaitForPendingFinalizers();
            GC.Collect();

            Assert.IsFalse(wref.IsAlive);
        }

        #endregion

        [TestMethod]
        public void HasAccess()
        {
            LoadProject(accessProject, "bph", "bph");
            var user = projectData.UsersManager.Users.First(x => x.Name == "bph");

            SimComponent component = new SimComponent();
            component.AccessLocal[user].Access = SimComponentAccessPrivilege.None;

            Assert.IsFalse(component.HasAccess(user, SimComponentAccessPrivilege.Read));
            Assert.IsFalse(component.HasAccess(user, SimComponentAccessPrivilege.Write));
            Assert.IsFalse(component.HasAccess(user, SimComponentAccessPrivilege.Release));
            Assert.IsFalse(component.HasAccess(user, SimComponentAccessPrivilege.Supervize));

            component.Visibility = SimComponentVisibility.AlwaysVisible;
            Assert.IsTrue(component.HasAccess(user, SimComponentAccessPrivilege.Read));
            Assert.IsFalse(component.HasAccess(user, SimComponentAccessPrivilege.Write));
            Assert.IsFalse(component.HasAccess(user, SimComponentAccessPrivilege.Release));
            Assert.IsFalse(component.HasAccess(user, SimComponentAccessPrivilege.Supervize));

            component.Visibility = SimComponentVisibility.VisibleInProject;
            component.AccessLocal[user].Access = SimComponentAccessPrivilege.Read;
            Assert.IsTrue(component.HasAccess(user, SimComponentAccessPrivilege.Read));
            Assert.IsFalse(component.HasAccess(user, SimComponentAccessPrivilege.Write));
            Assert.IsFalse(component.HasAccess(user, SimComponentAccessPrivilege.Release));
            Assert.IsFalse(component.HasAccess(user, SimComponentAccessPrivilege.Supervize));

            component.AccessLocal[user].Access = SimComponentAccessPrivilege.Read | SimComponentAccessPrivilege.Write;
            Assert.IsTrue(component.HasAccess(user, SimComponentAccessPrivilege.Read));
            Assert.IsTrue(component.HasAccess(user, SimComponentAccessPrivilege.Write));
            Assert.IsFalse(component.HasAccess(user, SimComponentAccessPrivilege.Release));
            Assert.IsFalse(component.HasAccess(user, SimComponentAccessPrivilege.Supervize));

            component.AccessLocal[user].Access = SimComponentAccessPrivilege.Read | SimComponentAccessPrivilege.Write | SimComponentAccessPrivilege.Supervize;
            Assert.IsTrue(component.HasAccess(user, SimComponentAccessPrivilege.Read));
            Assert.IsTrue(component.HasAccess(user, SimComponentAccessPrivilege.Write));
            Assert.IsFalse(component.HasAccess(user, SimComponentAccessPrivilege.Release));
            Assert.IsTrue(component.HasAccess(user, SimComponentAccessPrivilege.Supervize));

            component.AccessLocal[user].Access = SimComponentAccessPrivilege.Read | SimComponentAccessPrivilege.Write | SimComponentAccessPrivilege.Supervize | SimComponentAccessPrivilege.Release;
            Assert.IsTrue(component.HasAccess(user, SimComponentAccessPrivilege.Read));
            Assert.IsTrue(component.HasAccess(user, SimComponentAccessPrivilege.Write));
            Assert.IsTrue(component.HasAccess(user, SimComponentAccessPrivilege.Release));
            Assert.IsTrue(component.HasAccess(user, SimComponentAccessPrivilege.Supervize));
        }
    }
}
