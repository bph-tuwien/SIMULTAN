using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Threading.Tasks;

namespace SIMULTAN.Data.Components
{
    /// <summary>
    /// Parser for MultiValue calculations
    /// </summary>
    public class MultiValueCalculationParser
    {
        private static readonly Dictionary<ExpressionType, MultiValueCalculationBinaryOperation> defaultOperations = new Dictionary<ExpressionType, MultiValueCalculationBinaryOperation>
        {
            { ExpressionType.AddChecked, MultiValueCalculationBinaryOperation.MATRIX_SUM_REPEAT_COLUMN },
            { ExpressionType.MultiplyChecked, MultiValueCalculationBinaryOperation.MATRIX_PRODUCT }
        };

        /// <summary>
        /// Parses the expression tree created by the Calculation Parser and returns a MultiValue expression tree.
        /// Throws a NotSupportedException exception when an unsupported expression tree element is found.
        /// </summary>
        /// <param name="expression">The expression tree generated by the ParseFunction method of the CalculationParser</param>
        /// <returns>The MultiValue expression tree (if a valid one exists)</returns>
        public static SimMultiValueExpression Parse(Expression<Func<Dictionary<string, double>, double>> expression)
        {
            return ParseExpression(expression.Body);
        }


        #region Parsing


        private static SimMultiValueExpression ParseExpression(Expression expression)
        {
            if (expression is BinaryExpression binaryExpression)
                return ParseBinaryExpression(binaryExpression);
            else if (expression is MethodCallExpression methodExpression)
                return ParseMethodCallExpression(methodExpression);
            else if (expression is UnaryExpression unaryExpression)
                return ParseUnaryExpression(unaryExpression);
            else if (expression is ConstantExpression constExpression)
                return ParseConstantExpression(constExpression);

            throw new NotSupportedException(string.Format("Operation {0} not supported in Vector calculations", expression.NodeType));
        }

        private static SimMultiValueExpression ParseBinaryExpression(BinaryExpression expression)
        {
            //Check expression method
            if (defaultOperations.TryGetValue(expression.NodeType, out var operation))
            {
                return new SimMultiValueExpressionBinary(operation)
                {
                    Left = ParseExpression(expression.Left),
                    Right = ParseExpression(expression.Right)
                };
            }
            else
                throw new NotSupportedException(string.Format("Operation {0} not supported in Vector calculations", expression.NodeType));
        }

        private static SimMultiValueExpression ParseMethodCallExpression(MethodCallExpression expression)
        {
            if (CalculationParser.IsParameterExpression(expression)) //Parameter
            {
                if (expression.Arguments[0] is ConstantExpression constant)
                {
                    return new SimMultiValueExpressionParameter(constant.Value.ToString());
                }
            }
            else if (expression.Method.Name == "CallCustomFunction" && expression.Arguments.Count == 2
                && expression.Arguments[0] is ConstantExpression arg0 && arg0.Value is string arg0str && arg0str == "Transpose:1"
                && expression.Arguments[1].NodeType == ExpressionType.NewArrayInit && expression.Arguments[1] is NewArrayExpression arg1
                && arg1.Expressions.Count == 1)
            {

                return new SimMultiValueExpressionUnary(MultiValueCalculationUnaryOperation.Transpose)
                {
                    Operand = ParseExpression(arg1.Expressions[0])
                };
            }
            else
            {
                //Some Math function -> only constant body allowed (or combination of constants)
                //expression.
                try
                {
                    Expression<Func<double>> le = Expression.Lambda<Func<double>>(expression);
                    var leFunc = le.Compile();
                    var result = leFunc();

                    return new SimMultiValueExpressionDoubleConstant(result);

                }
                catch (Exception)
                {
                    throw new NotSupportedException(string.Format("Operation {1} ({0}) not supported with vector parameters",
                        expression.NodeType, expression.Method));
                }
            }

            throw new NotSupportedException(string.Format("Operation {1} ({0}) not supported in Vector calculations",
                        expression.NodeType, expression.Method));
        }

        private static SimMultiValueExpression ParseUnaryExpression(UnaryExpression expression)
        {
            if (expression.NodeType == ExpressionType.NegateChecked)
            {
                return new SimMultiValueExpressionUnary(MultiValueCalculationUnaryOperation.Negate)
                {
                    Operand = ParseExpression(expression.Operand)
                };
            }

            throw new NotSupportedException(string.Format("Operation {0} not supported in Vector calculations", expression.NodeType));
        }

        private static SimMultiValueExpressionDoubleConstant ParseConstantExpression(ConstantExpression expression)
        {
            return new SimMultiValueExpressionDoubleConstant((double)expression.Value);
        }

        #endregion
    }
}
