using SIMULTAN.Data.Assets;
using SIMULTAN.Data.FlowNetworks;
using SIMULTAN.Data.MultiValues;
using SIMULTAN.Data.Users;
using SIMULTAN.Excel;
using SIMULTAN.Exceptions;
using SIMULTAN.Serializer.DXF;
using SIMULTAN.Serializer.DXF.DXFEntities;
using SIMULTAN.Utils.Collections;
using SIMULTAN.Utils;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Windows.Threading;
using static SIMULTAN.Data.Components.SimCalculation;

namespace SIMULTAN.Data.Components
{
    /// <summary>
    /// The main data model class. Serves as a named container which stores other objects like
    /// Parameters (<see cref="Parameters"/>), Calculations (<see cref="Calculations"/>).
    /// Components itself serve as a Type (in a OOP sense). Each component may have instances which describe
    /// a specific item of the component's type. For details about instances see the <see cref="SimComponentInstance"/> class.
    /// 
    /// Components provide a tree-like structure where subcomponents are found in <see cref="Components"/>.
    /// In addition to storing the subcomponent, the component also stores the which function the component has in the
    /// <see cref="SimChildComponentEntry.Slot"/> property.
    /// 
    /// Components can reference each other via <see cref="ReferencedComponents"/>/<see cref="ReferencedBy"/>.
    /// 
    /// Access management is provided by the <see cref="AccessLocal"/> property. Write access is enforced by the <see cref="NotifyWriteAccess"/> method
    /// which throws an <see cref="AccessDeniedException"/> when a user without write access tries to access the component. Details about access
    /// management can be found in the <see cref="SimAccessProfile"/>.
    /// </summary>
    [DebuggerDisplay("[Component] {Name}, Id = {Id}")]
    public partial class SimComponent : SimObjectNew<SimComponentCollection>
    {
        #region Properties

        /// <summary>
        /// Returns the category of the component. This is the combination of all child component categories together with the
        /// categories of all parameters (<see cref="SimParameter.Category"/>)
        /// </summary>
        [ExcelMappingProperty("SIM_COMPONENT_CATEGORY")]
        public SimCategory Category
        {
            get { return this.category; }
            private set
            {
                this.category = value;
                this.NotifyPropertyChanged(nameof(Category));
            }
        }
        private SimCategory category;

        /// <summary>
        /// Stores the access profile for each <see cref="SimUserRole"/> and saves last writing, supervising and publishing access per user type.
        /// </summary>
        public SimAccessProfile AccessLocal
        {
            get { return this.accessLocal; }
            set
            {
                if (this.accessLocal != null)
                {
                    this.accessLocal.PropertyChanged -= AccessLocal_PropertyChanged;
                    this.accessLocal.AccessChanged -= AccessLocal_AccessChanged;
                }

                this.accessLocal = value;

                if (this.accessLocal != null)
                {
                    this.accessLocal.PropertyChanged += AccessLocal_PropertyChanged;
                    this.accessLocal.AccessChanged += AccessLocal_AccessChanged;
                }

                this.NotifyPropertyChanged(nameof(AccessLocal));
                NotifyAccessChanged();
            }
        }
        private SimAccessProfile accessLocal;

        /// <summary>
        /// Stores the function which a component may be used. For top-level components the slot is free to choose.
        /// For child components, the slot has to match the <see cref="SimChildComponentEntry.Slot"/> property.
        /// </summary>
        [ExcelMappingProperty("SIM_COMPONENT_CURRENTSLOT", FilterKey = "Slot")]
        public SimSlotBase CurrentSlot
        {
            get { return this.currentSlot; }
            set
            {
                if (this.currentSlot != value)
                {
                    this.RecordWriteAccess();

                    this.currentSlot = value;

                    if (this.ParentContainer != null)
                        this.ParentContainer.Slot = new SimSlot(value, this.ParentContainer.Slot.SlotExtension);

                    this.NotifyPropertyChanged(nameof(CurrentSlot));
                    this.NotifyChanged();
                }
            }
        }
        private SimSlotBase currentSlot;

        /// <summary>
        /// Returns True when the component has been generated by some algorithm (everything else than a user).
        /// This property can be set at any time and doesn't impose any restrictions (other than those imposed by the UI).
        /// </summary>
        [ExcelMappingProperty("SIM_OBJECT_ISAUTOGENERATED")]
        public bool IsAutomaticallyGenerated
        {
            get { return isAutomaticallyGenerated; }
            set
            {
                if (value != isAutomaticallyGenerated)
                {
                    this.NotifyWriteAccess();
                    isAutomaticallyGenerated = value;
                    NotifyPropertyChanged(nameof(IsAutomaticallyGenerated));
                    this.NotifyChanged();
                }
            }
        }
        private bool isAutomaticallyGenerated;

        /// <summary>
        /// Stores the container in which the component is placed.
        /// This property is set automatically when the component is added to a <see cref="Components"/> collection.
        /// Returns null when the component is a top-level element.
        /// </summary>
        public SimChildComponentEntry ParentContainer { get; internal set; }

        /// <summary>
        /// Returns the parent component, or Null when no parent exists
        /// </summary>
        public SimComponent Parent { get { return ParentContainer?.Parent; } }

        /// <summary>
        /// Stores in which way child components should be sorted. This property is only used by the UI but is persisted in the data model.
        /// </summary>
        public SimComponentContentSorting SortingType
        {
            get { return this.sorting_type; }
            set
            {
                if (this.sorting_type != value)
                {
                    this.NotifyWriteAccess();
                    this.sorting_type = value;
                    this.NotifyPropertyChanged(nameof(SortingType));
                    this.NotifyChanged();
                }
            }
        }
        private SimComponentContentSorting sorting_type = SimComponentContentSorting.ByName;

        /// <summary>
        /// The visibility of the component within and beyond a project.
        /// </summary>
        public SimComponentVisibility Visibility
        {
            get { return this.visibility; }
            set
            {
                if (this.visibility != value)
                {
                    this.NotifyWriteAccess();
                    this.visibility = value;
                    this.NotifyPropertyChanged(nameof(Visibility));
                    this.NotifyChanged();
                }
            }
        }
        private SimComponentVisibility visibility;

        /// <summary>
        /// The color of the component in a GUI.
        /// </summary>
        public System.Windows.Media.Color ComponentColor
        {
            get { return this.componentColor; }
            set
            {
                if (this.componentColor != value)
                {
                    this.NotifyWriteAccess();
                    this.componentColor = value;
                    this.NotifyPropertyChanged(nameof(ComponentColor));
                    this.NotifyChanged();
                }
            }
        }
        private System.Windows.Media.Color componentColor;

        /// <summary>
        /// Holds the id of an associated raster image for display in graphical editors.
        /// </summary>
        /// Currently not used
        [Obsolete]
        public long SymbolId
        {
            get { return this.symbolId; }
            set
            {
                if (this.symbolId != value)
                {
                    this.symbolId = value;
                    this.NotifyPropertyChanged(nameof(SymbolId));
                }
            }
        }
        private long symbolId;

        #endregion

        #region Contained Elements

        /// <summary>
        /// Stores the child components of this component. Users need write access to the current component in order to modify this collection.
        /// </summary>
        public SimChildComponentCollection Components { get; }

        /// <summary>
        /// Stores the parameters in the component
        /// </summary>
        public SimParameterCollection Parameters { get; }

        /// <summary>
        /// All calculations contained in this component. They can select parameters for in- and output
        /// only from the ones contained in this component or any of its sub-components. The order of the 
        /// calculations in the list corresponds to the sequence in which they have to be performed and is 
        /// automatically updated after adding, deleting or editing a calculation or a parameter.
        /// </summary>
        public SimCalculationCollection Calculations { get; }

        /// <summary>
        /// A list of all components referenced by this one. See <see cref="SimComponentReference"/> for more details
        /// </summary>
        public SimReferenceCollection ReferencedComponents { get; }
        /// <summary>
        /// A list of all components that reference the current one. Automatically generated from the <see cref="ReferencedComponents"/> collection
        /// </summary>
        public IReadOnlyList<SimComponentReference> ReferencedBy { get { return ReferencedBy_Internal; } }
        /// <summary>
        /// A list of all components that reference the current one. Automatically generated from the <see cref="ReferencedComponents"/> collection
        /// </summary>
        internal List<SimComponentReference> ReferencedBy_Internal { get; }

        /// <summary>
        /// A sequence of chat items (questions, answers, reactions, votes etc.).
        /// Represents the decision history of a component.
        /// </summary>
        public SimChat Conversation
        {
            get { return this.conversation; }
            internal set
            {
                this.conversation = value;
            }
        }
        private SimChat conversation;

        /// <summary>
        /// A list of assets used by this component. The list is not saved but reconstructed from the 
        /// saved asset manager after loading. Assets can be documents, geometry, etc. Changes are tracked in the <see cref="AssetManager"/>.
        /// </summary>
        public ReadOnlyObservableCollection<Asset> ReferencedAssets { get { return referencedAssetsReadonly; } }

        /// <summary>
        /// A list of assets used by this component. The list is not saved but reconstructed from the 
        /// saved asset manager after loading. Assets can be documents, geometry, etc. Changes are tracked in the <see cref="AssetManager"/>.
        /// </summary>
        internal ObservableCollection<Asset> ReferencedAssets_Internal
        {
            get { return referencedAssets; }
            private set
            {
                referencedAssets = value;
                referencedAssetsReadonly = new ReadOnlyObservableCollection<Asset>(referencedAssets);
                NotifyPropertyChanged(nameof(ReferencedAssets_Internal));
                NotifyPropertyChanged(nameof(ReferencedAssets));
            }
        }
        private ObservableCollection<Asset> referencedAssets;
        private ReadOnlyObservableCollection<Asset> referencedAssetsReadonly;

        #endregion

        #region Instances

        /// <summary>
        /// Stores the type of instance this component supports.
        /// </summary>
        public SimInstanceType InstanceType
        {
            get { return instanceType; }
            set
            {
                if (this.Instances.Count > 0)
                    throw new InvalidOperationException("Operation is only possible when no instances exist");

                if (instanceType != value)
                {
                    this.NotifyWriteAccess();
                    instanceType = value;
                    NotifyPropertyChanged(nameof(InstanceType));
                    this.NotifyChanged();
                }
            }
        }
        private SimInstanceType instanceType = SimInstanceType.None;

        /// <summary>
        /// Stores the instances of this component. Details about instances can be found in <see cref="SimComponentInstance"/>.
        /// </summary>
        public SimInstanceCollection Instances { get; }

        /// <summary>
        /// Reflects the state of the instances. Combined information collected from all instances.
        /// </summary>
        [ExcelMappingProperty("SIM_COMPONENT_GEOSTATE")]
        public SimInstanceState InstanceState
        {
            get { return this.instanceState; }
            private set
            {
                if (this.instanceState != value)
                {
                    this.instanceState = value;
                    this.NotifyPropertyChanged(nameof(InstanceState));
                }
            }
        }
        private SimInstanceState instanceState = new SimInstanceState();

        /// <summary>
        /// Returns true when at least on instance is bound to a network
        /// </summary>
        [ExcelMappingProperty("SIM_COMPONENT_ISBOUNDINNW")]
        public bool IsBoundInNetwork
        {
            get { return this.isBoundInNetwork; }
            protected set
            {
                if (this.isBoundInNetwork != value)
                {
                    this.isBoundInNetwork = value;
                    this.NotifyPropertyChanged(nameof(IsBoundInNetwork));
                }
            }
        }
        private bool isBoundInNetwork;

        /// <summary>
        /// Notifies the component that one of it's instances has changed a property that affects the instance state
        /// </summary>
        internal void OnInstanceStateChanged()
        {
            bool isInNetwork = false;
            bool isRealized = false;
            SimInstanceConnectionState state = SimInstanceConnectionState.Ok;

            foreach (var instance in this.Instances)
            {
                isInNetwork |= instance.Placements.Any(x => x is SimInstancePlacementNetwork);
                isRealized |= instance.State.IsRealized;

                if (instance.State.ConnectionState != SimInstanceConnectionState.Ok)
                    state = instance.State.ConnectionState;
            }

            this.InstanceState = new SimInstanceState(isRealized, state);
            this.IsBoundInNetwork = isInNetwork;
        }

        #endregion


        #region Mappings

        /// <summary>
        /// A lookup table of mappings to excel rules that map the component's content into Excel sheets.
        /// Each key consists of the Excel tool's name, the index of the mapped rule in the tool, the rule's name, and the traversal path leading to this component.
        /// A component can have a mapping to the same rule in the same tool along two different traversal paths.
        /// </summary>
        public ObservableDictionary<string, ExcelComponentMapping> MappingsPerExcelTool { get; private set; }

        /// <summary>
        /// A list of mappings to other components that can be used by this one as calculators. This allows to reuse
        /// calculation sequences defined in another component an arbitrary number of times.
		/// This property is only set by the constructors
        /// </summary>
        public IReadOnlyObservableCollection<CalculatorMapping> CalculatorMappings
        {
            get { return calculatorMappings; }
        }
        internal ElectivelyObservableCollection<CalculatorMapping> CalculatorMappings_Internal
        {
            get { return calculatorMappings; }
            private set
            {
                if (calculatorMappings != null)
                    throw new NotSupportedException("This property may only be set once");

                calculatorMappings = value;
            }
        }
        private ElectivelyObservableCollection<CalculatorMapping> calculatorMappings;

        /// <summary>
        /// Derived: A list of all components that use this one as a calculator.
        /// </summary>
        public List<SimComponent> MappedToBy { get; private set; }

        #endregion

        #region Events

        /// <summary>
        /// Handler for the IsBeingDelted event.
        /// </summary>
        /// <param name="sender"></param>
        public delegate void IsBeingDeletedEventHandler(object sender);
        /// <summary>
        /// Emitted just before the component is being deleted.
        /// </summary>
        public event IsBeingDeletedEventHandler IsBeingDeleted;
        /// <summary>
        /// Emits the IsBeingDelted event.
        /// </summary>
        public void OnIsBeingDeleted()
        {
            this.IsBeingDeleted?.Invoke(this);

            foreach (var entry in Components)
            {
                entry?.Component?.OnIsBeingDeleted();
            }
        }

        /// <summary>
        /// Invoked when the access rules have been changed. E.g. when <see cref="AccessLocal"/> is changed or when the
        /// access rights inside the <see cref="SimAccessProfile"/> are modified.
        /// </summary>
        public event EventHandler AccessChanged;
        /// <summary>
        /// Invokes the <see cref="AccessChanged"/> event
        /// </summary>
        protected void NotifyAccessChanged()
        {
            this.AccessChanged?.Invoke(this, EventArgs.Empty);
        }

        #endregion


        /// <summary>
        /// Initializes a new, empty instance of the Component class.
        /// Same as calling <see cref="SimComponent(SimUserRole)"/> with the <see cref="SimUserRole.ADMINISTRATOR"/>
        /// </summary>
        public SimComponent() : this(SimUserRole.ADMINISTRATOR) { }

        /// <summary>
        /// Initializes a new, empty instance of the Component class.
        /// </summary>
        /// <param name="owner">The user which has write access</param>
        public SimComponent(SimUserRole owner)
        {
            // contained entities
            this.Components = new SimChildComponentCollection(this);
            this.Parameters = new SimParameterCollection(this);
            this.Calculations = new SimCalculationCollection(this);

            this.ReferencedBy_Internal = new List<SimComponentReference>();
            this.ReferencedComponents = new SimReferenceCollection(this);

            // geometry (default state: NONE)
            this.Instances = new SimInstanceCollection(this);

            // general
            this.Id = SimId.Empty;
            this.Name = string.Empty;
            this.Description = string.Empty;

            // management
            this.Category = SimCategory.None;
            this.AccessLocal = new SimAccessProfile(owner);
            this.CurrentSlot = new SimSlotBase(ComponentUtils.COMP_SLOT_UNDEFINED);

            // symbol
            this.SymbolId = -1;

            // factory properties
            this.Factory = null;

            // mapping for calculations
            this.CalculatorMappings_Internal = new ElectivelyObservableCollection<CalculatorMapping>();
            this.MappedToBy = new List<SimComponent>();

            // mapping to excel tools
            this.MappingsPerExcelTool = new ObservableDictionary<string, ExcelComponentMapping>();

            // assets
            this.ReferencedAssets_Internal = new ObservableCollection<Asset>();
            // conversation
            this.Conversation = new SimChat();

            // project
            this.Visibility = SimComponentVisibility.VisibleInProject;
            this.ComponentColor = System.Windows.Media.Color.FromArgb(255, 0, 255, 0);
            this.sorting_type = SimComponentContentSorting.ByName;

            // default parameters
            AddPropagationParametersForInstancing();
        }

        /// <summary>
        /// Initializes a new instance of the Component class by copying all data recursively from another component
        /// References are rebound to the copied ones when the reference points to the copied subtree.
        /// </summary>
        /// <param name="original">The component to copy from</param>
        public SimComponent(SimComponent original)
        {
            if (original == null)
                throw new ArgumentNullException(nameof(original));

            this.Instances = new SimInstanceCollection(this);
            this.Components = new SimChildComponentCollection(this);
            this.Parameters = new SimParameterCollection(this);
            this.Calculations = new SimCalculationCollection(this);

            this.ReferencedBy_Internal = new List<SimComponentReference>();
            this.ReferencedComponents = new SimReferenceCollection(this);

            var parameterCopyRecord = new Dictionary<SimParameter, SimParameter>();
            var componentCopyRecord = new Dictionary<SimComponent, SimComponent>();

            CopyConstructorInit(original, parameterCopyRecord, componentCopyRecord);

            //Rebind references
            RebindReferences(this, componentCopyRecord);
        }

        private SimComponent(SimComponent _original, Dictionary<SimParameter, SimParameter> parameterCopyRecord, Dictionary<SimComponent, SimComponent> componentCopyRecord)
        {
            this.Instances = new SimInstanceCollection(this);
            this.Components = new SimChildComponentCollection(this);
            this.Parameters = new SimParameterCollection(this);
            this.Calculations = new SimCalculationCollection(this);

            this.ReferencedBy_Internal = new List<SimComponentReference>();
            this.ReferencedComponents = new SimReferenceCollection(this);

            CopyConstructorInit(_original, parameterCopyRecord, componentCopyRecord);
        }

        /// <summary>
        /// Initializes a new instance of the Component class. Used for parsing components from a DXF file
        /// </summary>
        /// <remarks>
        /// Does NOT restore referenced components immediately.
        /// The component factory attempts to restore the references WHEN ALL COMPONENTS HAVE BEEN PARSED
        /// </remarks>
        /// <param name="globalId">The global id of the component</param>
        /// <param name="localId">The local id of the component</param>
        /// <param name="name">The name of the component</param>
        /// <param name="description">A description text</param>
        /// <param name="isAutomaticallyGenerated">When set to True, the component is marked as being automatically created</param>
        /// <param name="accessLocal">The access profile for this component</param>
        /// <param name="currentSlot">The slot base for this component</param>
        /// <param name="components">A list of all child components together with their full slot</param>
        /// <param name="referencedComponents">
        /// A list of all referenced components. This data is temporarily stored and references are restored when
        /// calling <see cref="RestoreReferences(Dictionary{SimObjectId, SimFlowNetworkElement}, AssetManager)"/>
        /// </param>
        /// <param name="parameters">All parameters contained in this component</param>
        /// <param name="calculations">Initialization data for the calculations in this component. References to parameters are restored here.</param>
        /// <param name="instanceType">The instance type of this component</param>
        /// <param name="instances">The instances of this component</param>
        /// <param name="calculatorMappings">All mappings to calculator components</param>
        /// <param name="excelMappings">The mappings of this component to excel tools</param>
        /// <param name="chat">The chat items of this component</param>
        /// <param name="visibility">The visibility of this component inside the project</param>
        /// <param name="color">The display color of this component</param>
        /// <param name="sorting">Specifies how child components should be sorted in the UI</param>
        /// <param name="symbolId">Id of the symbol (currently not in use)</param>
        internal SimComponent(Guid globalId, long localId, string name, string description, bool isAutomaticallyGenerated,
                           SimAccessProfile accessLocal, SimSlotBase currentSlot,
                           IEnumerable<(SimSlot slot, SimComponent component)> components,
                           IEnumerable<SimComponentReference> referencedComponents,
                           IEnumerable<SimParameter> parameters, IEnumerable<CalculationInitializationData> calculations,
                           SimInstanceType instanceType, IEnumerable<SimComponentInstance> instances, IEnumerable<CalculatorMapping> calculatorMappings,
                           IDictionary<string, ExcelComponentMapping> excelMappings,
                           IEnumerable<SimChatItem> chat, SimComponentVisibility visibility, System.Windows.Media.Color color,
                           SimComponentContentSorting sorting,
                           long symbolId)
        {
            this.Instances = new SimInstanceCollection(this);
            this.InstanceType = instanceType;

            // general
            this.Id = new SimId(globalId, localId);
            this.Name = name;
            this.Description = description;
            this.IsAutomaticallyGenerated = isAutomaticallyGenerated;

            // MANAGEMENT 1 - TMP (for usage during the filling in of parameters and subcomponents)
            this.Category = SimCategory.None;
            this.AccessLocal = new SimAccessProfile(SimUserRole.ADMINISTRATOR);

            // CONTAINED ENTITIES
            // // -- SubComponents (do NOT copy!)
            this.Components = new SimChildComponentCollection(this);
            foreach (var entry in components)
            {
                this.Components.Add(new SimChildComponentEntry(entry.slot, entry.component));
            }

            // // -- referenced Components (just prepare containers)
            this.ReferencedBy_Internal = new List<SimComponentReference>();
            this.ReferencedComponents = new SimReferenceCollection(this);
            foreach (var entry in referencedComponents)
                this.ReferencedComponents.Add(entry);

            // // -- Contained Parameters (do NOT copy!)
            this.Parameters = new SimParameterCollection(this);
            foreach (var p in parameters)
                this.Parameters.Add(p);

            // // -- Contained Calculations in the correct order
            // // -- assumes that the calculation was correctly saved!
            this.Calculations = new SimCalculationCollection(this);

            var flat_parameters = ComponentWalker.GetFlatParameters(this).ToDictionary(x => x.Id.LocalId, x => x);
            foreach (CalculationInitializationData calcP in calculations)
            {
                // compose the actual parameter lists
                Dictionary<string, SimParameter> parameters_in = new Dictionary<string, SimParameter>();
                foreach (var entry in calcP.InputParamsPreview)
                {
                    if (entry.Value.HasValue && flat_parameters.TryGetValue(entry.Value.Value, out var param))
                        parameters_in.Add(entry.Key, param);
                    else
                        parameters_in.Add(entry.Key, null);
                }

                Dictionary<string, SimParameter> parameters_out = new Dictionary<string, SimParameter>();
                foreach (var entry in calcP.ReturnParamsPreview)
                {
                    if (entry.Value.HasValue && flat_parameters.TryGetValue(entry.Value.Value, out var param))
                    {
                        parameters_out.Add(entry.Key, param);
                    }
                    else
                        parameters_out.Add(entry.Key, null);
                }
                // re-construct the calculation
                SimCalculation calc = new SimCalculation(calcP.LocalID, calcP.Expression, calcP.Name, parameters_in, parameters_out,
                    calcP.MetaData, calcP.VectorOperationList,
                    calcP.NrExecutions, calcP.OverrideVectorResult,
                    calcP.AggregationMethod);
                this.Calculations.Add(calc);
            }

            // MANAGEMENT 2 (overrides the changes made during the filling in of parameters and subcomponents)
            GatherCategoryInfo();
            this.AccessLocal = accessLocal; // AFTER 'FitsInSlots' in order to adopt user changes made after the slot selection
            this.CurrentSlot = currentSlot;

            // symbol
            this.SymbolId = symbolId;

            // geometry
            foreach (SimComponentInstance gr in instances)
            {
                this.Instances.Add(gr);
            }

            // mapping to calculations
            this.CalculatorMappings_Internal = new ElectivelyObservableCollection<CalculatorMapping>(calculatorMappings);
            this.MappedToBy = new List<SimComponent>();

            // mapping to excel tools
            this.MappingsPerExcelTool = new ObservableDictionary<string, ExcelComponentMapping>(excelMappings);

            // assets are added in a post-processing step
            this.ReferencedAssets_Internal = new ObservableCollection<Asset>();

            // the conversation
            this.Conversation = new SimChat(chat);

            // project-relevant
            this.Visibility = visibility;
            this.ComponentColor = color;

            // view-relevant
            this.SortingType = sorting;
        }


        #region Ctor Helper

        private void CopyConstructorInit(SimComponent _original, Dictionary<SimParameter, SimParameter> parameterCopyRecord, Dictionary<SimComponent, SimComponent> componentCopyRecord)
        {
            componentCopyRecord.Add(_original, this);

            this.InstanceType = _original.InstanceType;

            // general

            this.Id = SimId.Empty;
            this.Factory = null;

            this.Name = _original.Name;
            this.Description = _original.Description;
            this.IsAutomaticallyGenerated = _original.IsAutomaticallyGenerated;

            this.Visibility = _original.Visibility;
            this.ComponentColor = _original.ComponentColor;
            this.SortingType = _original.SortingType;

            this.Category = SimCategory.None;
            this.AccessLocal = new SimAccessProfile(_original.AccessLocal);
            this.CurrentSlot = _original.CurrentSlot;
            this.SymbolId = _original.SymbolId;

            // SubComponents
            foreach (var entry in _original.Components)
            {
                SimComponent c = entry.Component;
                if (c != null)
                {
                    if (c.IsAutomaticallyGenerated) continue;

                    SimComponent c_copy = new SimComponent(c, parameterCopyRecord, componentCopyRecord);
                    this.Components.Add(new SimChildComponentEntry(entry.Slot, c_copy));
                }
                else
                    this.Components.Add(new SimChildComponentEntry(entry.Slot));
            }

            // References
            foreach (var entry in _original.ReferencedComponents)
            {
                var target = entry.Target;

                //This is not exactly necessary (since RebindReferences has to be called after all constructors anyway),
                //but it improves performance to do it here too.
                if (target != null && componentCopyRecord.TryGetValue(target, out var copiedTarget))
                    target = copiedTarget;

                //this.AddReferencedComponent(slot_cp, target);
                this.ReferencedComponents.Add(new SimComponentReference(entry.Slot, target));
            }

            // Parameters
            foreach (var p_orig in _original.Parameters)
            {
                if (p_orig != null)
                {
                    SimParameter p_copy = p_orig.Clone();
                    this.Parameters.Add(p_copy);
                    parameterCopyRecord.Add(p_orig, p_copy);
                }
            }

            // Calculations
            foreach (SimCalculation calc in _original.Calculations)
            {
                SimCalculation calc_copy = new SimCalculation(calc);

                foreach (var entry in calc.InputParams.ToList())
                {
                    if (entry.Value != null)
                    {
                        if (parameterCopyRecord.TryGetValue(entry.Value, out var newTarget))
                            calc_copy.InputParams[entry.Key] = newTarget;
                        else
                            calc_copy.InputParams[entry.Key] = null;
                    }
                }
                foreach (var entry in calc.ReturnParams.ToList())
                {
                    if (entry.Value != null)
                    {
                        if (parameterCopyRecord.TryGetValue(entry.Value, out var newTarget))
                            calc_copy.ReturnParams[entry.Key] = newTarget;
                        else
                            calc_copy.ReturnParams[entry.Key] = null;
                    }
                }
                this.Calculations.Add(calc_copy);
            }

            // MANAGEMENT 2 (overrides the changes made during the filling in of parameters and subcomponents)
            this.Category = _original.Category;

            // mapping for calculations -> copy them
            this.CalculatorMappings_Internal = new ElectivelyObservableCollection<CalculatorMapping>();
            foreach (CalculatorMapping m in _original.CalculatorMappings)
            {
                CalculatorMapping m_copy = m.ExchangeDataParameter(parameterCopyRecord);
                if (m_copy != null)
                {
                    this.CalculatorMappings_Internal.Add(m_copy);
                    m_copy.Calculator.MappedToBy.Add(this);
                }
            }
            this.MappedToBy = new List<SimComponent>();

            // mapping for excel tools -> do not copy
            this.MappingsPerExcelTool = new ObservableDictionary<string, ExcelComponentMapping>();

            // assets -> do not copy
            this.ReferencedAssets_Internal = new ObservableCollection<Asset>();
            // conversation -> do not copy
            this.Conversation = new SimChat();
        }

        private void AddPropagationParametersForInstancing()
        {
            SimParameter p21 = new SimParameter(ReservedParameters.RP_INST_PROPAGATE, "-", 0.0, 0.0, double.MaxValue);
            p21.IsAutomaticallyGenerated = true;
            p21.TextValue = "All parameter values are propagated to the persistent instance values";
            p21.Category |= SimCategory.Communication;
            p21.Propagation = SimInfoFlow.Automatic;
            p21.AllowedOperations = SimParameterOperations.EditValue;

            this.Parameters.Add(p21);
        }

        private void RebindReferences(SimComponent component, Dictionary<SimComponent, SimComponent> componentCopyRecord)
        {
            foreach (var reference in component.ReferencedComponents.ToList())
            {
                if (reference.Target != null && componentCopyRecord.TryGetValue(reference.Target, out var newTarget))
                {
                    reference.Target = newTarget;
                }
            }

            foreach (var child in component.Components.Where(x => x.Component != null))
                RebindReferences(child.Component, componentCopyRecord);
        }

        #endregion

        #region METHODS: local access management

        /// <summary>
        /// Returns true when the user has the given access right
        /// </summary>
        /// <param name="user">The user</param>
        /// <param name="accessType">The access type that should be checked</param>
        /// <returns></returns>
        public bool HasAccess(SimUser user, SimComponentAccessPrivilege accessType)
        {
            if (accessType == SimComponentAccessPrivilege.Read && this.Visibility == SimComponentVisibility.AlwaysVisible)
                return true;

            if (user == null)
                return false;
            return this.AccessLocal[user.Role].Access.HasFlag(accessType);
        }
        /// <summary>
        /// Returns true when the user has the given access right on this component and on all subcomponents
        /// </summary>
        /// <param name="user">The user</param>
        /// <param name="accessType">The access type that should be checked</param>
        /// <returns></returns>
        public bool HasSubtreeAccess(SimUser user, SimComponentAccessPrivilege accessType)
        {
            if (!HasAccess(user, accessType))
                return false;

            return Components.All(x => x.Component == null || x.Component.HasSubtreeAccess(user, accessType));
        }

        /// <summary>
        /// Notifies the component about a write access.
        /// Throws an <see cref="AccessDeniedException"/> when the user doesn't have write access to the component.
        /// The write access is recorded in the <see cref="SimComponent.AccessLocal"/>
        /// </summary>
        internal void RecordWriteAccess()
        {
            if (this.Factory != null && this.Factory.EnableAccessChecking && this.Factory.ProjectData.UsersManager != null)
            {
                if (this.Factory.ProjectData.UsersManager.CurrentUser == null)
                    throw new AccessDeniedException();

                var role = this.Factory.ProjectData.UsersManager.CurrentUser.Role;
                SimAccessProfileEntry tracker = AccessLocal[role];
                if (!(tracker.Access.HasFlag(SimComponentAccessPrivilege.Write)))
                    throw new AccessDeniedException();

                // record the access
                tracker.LastAccessWrite = DateTime.Now;
            }
        }

        /// <inheritdoc/>
        protected override void NotifyWriteAccess()
        {
            this.RecordWriteAccess();
            base.NotifyWriteAccess();
        }

        /// <summary>
        /// Records a write access no matter if the user has write access. 
        /// This is necessary, for example, when a whole subtree is added since subtree children might not have the same access rights as the parent
        /// 
        /// When <see cref="SimComponentCollection.EnableAccessChecking"/> is False, no access is recorded
        /// </summary>
        /// <param name="user">The user for which the write access should be set</param>
        internal void ForceRecordWriteAccess(SimUser user)
        {
            if (this.Factory == null || this.Factory.EnableAccessChecking)
            {
                SimAccessProfileEntry tracker = AccessLocal[user.Role];
                tracker.ForceSetWriteAccess(user, DateTime.Now);
            }
        }

        #endregion

        #region METHODS: To String

        [Obsolete]
        public override string ToString()
        {
            string output = "";
            output += " " + this.Id + ": " + this.Name + "( " + this.Description + " ) ";
            output += "sub-comp {" + this.Components.Count + "} ";
            output += "ref-comp {" + this.ReferencedComponents.Count + "} ";
            output += "params {" + this.Parameters.Count + "}";

            return output;
        }

        /// <summary>
        /// A string containing the component's id, name, description and current slot.
        /// </summary>
        /// <returns></returns>
        [Obsolete]
        public string ToInfoString()
        {
            return this.CurrentSlot + ": {" + this.LocalID + "}" + this.Name + " - " + this.Description;
        }

        /// <summary>
        /// Serializing method.
        /// </summary>
        /// <param name="_sb">the string builder that holds the serialized content</param>
        /// <param name="_include_chat">if true, include the chat (for monolithic saving), if false - do not (for distributed saving)</param>
        /// <param name="_key">the key under which the component is saved (for sub-components)</param>
        public virtual void AddToExport(ref StringBuilder _sb, bool _include_chat = true, string _key = null)
        {
            if (_sb == null) return;

            _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
            _sb.AppendLine(ParamStructTypes.COMPONENT);                               // COMPONENT

            if (!(string.IsNullOrEmpty(_key)))
            {
                _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_KEY).ToString());
                _sb.AppendLine(_key);
            }

            _sb.AppendLine(((int)ParamStructCommonSaveCode.CLASS_NAME).ToString());
            _sb.AppendLine(this.GetType().ToString());

            // body of component class export
            this.AddToExportBody(ref _sb, _include_chat);

            // signify end of complex entity
            _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
            _sb.AppendLine(ParamStructTypes.SEQUENCE_END);                            // SEQEND

        }

        private void AddToExportBody(ref StringBuilder _sb, bool _include_chat)
        {
            string tmp = null;

            // general
            _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_LOCATION).ToString());
            _sb.AppendLine(this.Id.GlobalId.ToString());

            _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_ID).ToString());
            _sb.AppendLine(this.Id.LocalId.ToString());

            _sb.AppendLine(((int)ComponentSaveCode.NAME).ToString());
            _sb.AppendLine(this.Name);

            _sb.AppendLine(((int)ComponentSaveCode.DESCRIPTION).ToString());
            tmp = this.Description.Replace(Environment.NewLine, ParamStructTypes.DELIMITER_WITHIN_ENTRY);
            _sb.AppendLine(tmp);

            _sb.AppendLine(((int)ComponentSaveCode.GENERATED_AUTOMATICALLY).ToString());
            tmp = (this.IsAutomaticallyGenerated) ? "1" : "0";
            _sb.AppendLine(tmp);

            // management
            _sb.AppendLine(((int)ComponentSaveCode.CATEGORY).ToString());
            _sb.AppendLine(ComponentUtils.CategoryToString(this.Category));

            this.AccessLocal.AddToExport(ref _sb, false);

            _sb.AppendLine(((int)ComponentSaveCode.FUNCTION_SLOT_CURRENT).ToString());
            _sb.AppendLine(this.CurrentSlot.Base);

            // CONTAINED COMPONENTS
            if (this.Components.Count == 0)
            {
                _sb.AppendLine(((int)ComponentSaveCode.CONTAINED_COMPONENTS).ToString());
                _sb.AppendLine("0");
                _sb.AppendLine(((int)ComponentSaveCode.CONTAINED_COMPONENT_SLOTS).ToString());
                _sb.AppendLine("0");
            }
            else
            {
                int nr_sComp_full = this.Components.Count(x => x.Component != null);
                int nr_sComp_empty = this.Components.Count - nr_sComp_full;

                // -- save the actual components
                _sb.AppendLine(((int)ComponentSaveCode.CONTAINED_COMPONENTS).ToString());
                _sb.AppendLine(nr_sComp_full.ToString());

                _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
                _sb.AppendLine(ParamStructTypes.ENTITY_SEQUENCE);                         // ENTSEQ

                foreach (var entry in this.Components)
                {
                    string slot = entry.Slot.ToSerializerString();
                    SimComponent sComp = entry.Component;
                    if (sComp != null)
                        sComp.AddToExport(ref _sb, _include_chat, slot);
                }

                _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
                _sb.AppendLine(ParamStructTypes.SEQUENCE_END);                            // SEQEND
                _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
                _sb.AppendLine(ParamStructTypes.ENTITY_CONTINUE);                         // ENTCTN

                // -- save the empty slots
                _sb.AppendLine(((int)ComponentSaveCode.CONTAINED_COMPONENT_SLOTS).ToString());
                _sb.AppendLine(nr_sComp_empty.ToString());

                foreach (var entry in this.Components)
                {
                    if (entry.Component == null)
                    {
                        // just save the slots
                        _sb.AppendLine(((int)ParamStructCommonSaveCode.STRING_VALUE).ToString());
                        _sb.AppendLine(entry.Slot.ToSerializerString());
                    }
                }
            }

            // REFERENCED COMPONENTS
            _sb.AppendLine(((int)ComponentSaveCode.REFERENCED_COMPONENTS).ToString());
            _sb.AppendLine(this.ReferencedComponents.Count().ToString());

            foreach (var entry in this.ReferencedComponents)
            {
                // save the slot
                _sb.AppendLine(((int)ParamStructCommonSaveCode.STRING_VALUE).ToString());
                _sb.AppendLine(entry.Slot.ToSerializerString());
                // save the component id
                _sb.AppendLine(((int)ParamStructCommonSaveCode.X_VALUE).ToString());
                _sb.AppendLine(entry.TargetId.LocalId.ToString());
                // save the location guid
                _sb.AppendLine(((int)ParamStructCommonSaveCode.Y_VALUE).ToString());
                _sb.AppendLine(entry.TargetId.GlobalId.ToString());
            }

            // CONTAINED PARAMETERS
            _sb.AppendLine(((int)ComponentSaveCode.CONTAINED_PARAMETERS).ToString());
            _sb.AppendLine(this.Parameters.Count().ToString());

            if (this.Parameters.Count() > 0)
            {
                _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
                _sb.AppendLine(ParamStructTypes.ENTITY_SEQUENCE);                         // ENTSEQ

                foreach (var entry in this.Parameters)
                {
                    entry.AddToExport(ref _sb);
                }

                _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
                _sb.AppendLine(ParamStructTypes.SEQUENCE_END);                            // SEQEND
                _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
                _sb.AppendLine(ParamStructTypes.ENTITY_CONTINUE);                         // ENTCTN
            }

            // CONTAINED CALCULATIONS
            _sb.AppendLine(((int)ComponentSaveCode.CONTAINED_CALCULATIONS).ToString());
            _sb.AppendLine(this.Calculations.Count.ToString());

            if (this.Calculations.Count > 0)
            {
                _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
                _sb.AppendLine(ParamStructTypes.ENTITY_SEQUENCE);                         // ENTSEQ

                foreach (SimCalculation calc in this.Calculations)
                {
                    if (calc == null) continue;
                    calc.AddToExport(ref _sb);
                }

                _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
                _sb.AppendLine(ParamStructTypes.SEQUENCE_END);                            // SEQEND
                _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
                _sb.AppendLine(ParamStructTypes.ENTITY_CONTINUE);                         // ENTCTN
            }

            // GEOMETRIC RELATIONSHIPS (added 15.11.2016)
            _sb.AppendLine(((int)ComponentSaveCode.INSTANCE_TYPE).ToString());
            _sb.AppendLine(DXFComponentInstance.InstanceTypeToString(this.InstanceType));

            _sb.AppendLine(((int)ComponentSaveCode.RELATIONSHIPS_TO_GEOMETRY).ToString());
            _sb.AppendLine(this.Instances.Count.ToString());

            if (this.Instances.Count > 0)
            {
                _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
                _sb.AppendLine(ParamStructTypes.ENTITY_SEQUENCE);                         // ENTSEQ

                foreach (SimComponentInstance gr in this.Instances)
                {
                    if (gr == null) continue;
                    gr.AddToExport(ref _sb);
                }

                _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
                _sb.AppendLine(ParamStructTypes.SEQUENCE_END);                            // SEQEND
                _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
                _sb.AppendLine(ParamStructTypes.ENTITY_CONTINUE);                         // ENTCTN
            }

            // MAPPINGS TO COMPONENTS (added 30.08.2017)
            _sb.AppendLine(((int)ComponentSaveCode.MAPPINGS_TO_COMPONENTS).ToString());
            _sb.AppendLine(this.CalculatorMappings.Count.ToString());

            if (this.CalculatorMappings.Count > 0)
            {
                _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
                _sb.AppendLine(ParamStructTypes.ENTITY_SEQUENCE);                         // ENTSEQ

                foreach (CalculatorMapping m in this.CalculatorMappings)
                {
                    if (m == null) continue;
                    m.AddToExport(ref _sb);
                }

                _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
                _sb.AppendLine(ParamStructTypes.SEQUENCE_END);                            // SEQEND
                _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
                _sb.AppendLine(ParamStructTypes.ENTITY_CONTINUE);                         // ENTCTN
            }

            // symbol
            _sb.AppendLine(((int)ComponentSaveCode.SYMBOL_ID).ToString());
            _sb.AppendLine(this.SymbolId.ToString());

            // MAPPINGS TO EXCEL TOOLS (added 18.05.2018)
            _sb.AppendLine(((int)ComponentSaveCode.MAPPINGS_TO_EXCEL_TOOLS).ToString());
            _sb.AppendLine(this.MappingsPerExcelTool.Count.ToString());

            _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
            _sb.AppendLine(ParamStructTypes.ENTITY_SEQUENCE);                         // ENTSEQ

            foreach (var entry in this.MappingsPerExcelTool)
            {
                string key = entry.Key;
                ExcelComponentMapping m = entry.Value;
                if (m != null)
                    m.AddToExport(ref _sb, key);
            }

            _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
            _sb.AppendLine(ParamStructTypes.SEQUENCE_END);                            // SEQEND
            _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
            _sb.AppendLine(ParamStructTypes.ENTITY_CONTINUE);                         // ENTCTN

            // CONVERSATION (added 26.12.2018)
            if (_include_chat)
                this.Conversation.AddToExport(ref _sb);

            // project-relevant properties
            _sb.AppendLine(((int)ComponentSaveCode.VISIBILTY).ToString());
            _sb.AppendLine(this.Visibility.ToString());

            // colors
            _sb.AppendLine(((int)ComponentSaveCode.COLOR).ToString());
            _sb.AppendLine("1");

            // sorting type
            _sb.AppendLine(((int)ComponentSaveCode.SORTING_TYPE).ToString());
            _sb.AppendLine(this.SortingType.ToString());

            _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
            _sb.AppendLine(ParamStructTypes.ENTITY_SEQUENCE);                         // ENTSEQ

            ComponentUtils.AddColorToExport(this.ComponentColor, ref _sb);

            _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
            _sb.AppendLine(ParamStructTypes.SEQUENCE_END);                            // SEQEND
            _sb.AppendLine(((int)ParamStructCommonSaveCode.ENTITY_START).ToString()); // 0
            _sb.AppendLine(ParamStructTypes.ENTITY_CONTINUE);                         // ENTCTN
        }

        #endregion

        #region Contained object data propagation

        private void ReactToParameterPropagationChanged(SimParameter p)
        {
            var comp = this;

            bool foundMin = false, foundMax = false;
            bool foundValue = false;

            //Adapt value only when a reference parameter and when no MVpointer is attached
            if (p.Propagation != SimInfoFlow.FromReference || p.MultiValuePointer != null)
                foundValue = true;

            //Find and update the closest parameter which matches the name
            while (comp != null)
            {
                foreach (var entry in comp.ReferencedComponents)
                {
                    if (entry.Target != null)
                    {
                        foreach (var rP in ComponentWalker.GetFlatParameters(entry.Target))
                        {
                            if (!foundValue && rP.Name == p.Name)
                            {
                                p.ValueCurrent = rP.ValueCurrent;
                                p.TextValue = rP.TextValue;
                                foundValue = true;
                            }
                            else if (!foundMin && rP.Name.EndsWith("MIN"))
                            {
                                p.ValueMin = rP.ValueCurrent;
                                foundMin = true;
                            }
                            else if (!foundMax && rP.Name.EndsWith("MAX"))
                            {
                                p.ValueMax = rP.ValueCurrent;
                                foundMin = true;
                            }

                            //Early exit when all references are found
                            if (foundValue && foundMin && foundMax)
                                return;
                        }
                    }
                }

                comp = comp.Parent;
            }
        }

        internal void OnParameterValueChanged(SimParameter p)
        {
            // propagate info to all components that reference this one
            this.PropagateRefParamValueFromClosestRef(p);
            // update all instances
            this.Instances?.OnParameterValueChanged(p);
        }

        /// <inheritdoc />
        protected override void OnFactoryChanged(SimComponentCollection newFactory, SimComponentCollection oldFactory)
        {
            //Update calculation Ids
            this.Calculations.NotifyFactoryChanged(this.Factory, oldFactory);
            this.Parameters.NotifyFactoryChanged(this.Factory, oldFactory);
            this.Instances.NotifyFactoryChanged();

            this.Components.NotifyFactoryChanged(this.Factory, oldFactory);
            this.ReferencedComponents.NotifyFactoryChanged(this.Factory, oldFactory);

            base.OnFactoryChanged(newFactory, oldFactory);
        }

        private void AccessLocal_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            if (e.PropertyName == nameof(SimAccessProfile.ProfileState))
            {
                NotifyAccessChanged();
            }
        }
        private void AccessLocal_AccessChanged(object sender, EventArgs e)
        {
            NotifyAccessChanged();
        }

        /// <summary>
        /// Sets the category of the component as an aggregation of the categories 
        /// of its parameters and sub-components.
        /// </summary>
        private void GatherCategoryInfo()
        {
            SimCategory newC = SimCategory.None;
            foreach (var entry in this.Components.Where(x => x.Component != null))
            {
                newC |= entry.Component.Category;
            }
            foreach (var entry in this.Parameters)
            {
                newC |= entry.Category;
            }
            this.Category = newC;
        }

        #endregion

        /// <summary>
        /// Restores the references to other objects in the project after loading. This method needs to be called when all objects have been create and registered
        /// in their appropriate factories. Especially, this method may only be called when ALL components have been created.
        /// Restores referenced components, asset references, objects referenced by instances and calculator mappings.
        /// The method calls itself recursively for all child components.
        /// </summary>
        /// <param name="networkElements">A list of all network elements. This parameter will be obsolete when network elements are registered in the IdGenerator</param>
        /// <param name="assetManager">The asset manager in this project</param>
        public void RestoreReferences(Dictionary<SimObjectId, SimFlowNetworkElement> networkElements, AssetManager assetManager)
        {
            if (Factory == null)
                throw new InvalidOperationException("May only be called on components which are part of a factory");

            //Restore component references
            this.ReferencedComponents.ForEach(x => x.RestoreReferences());

            //Restore calculator mappings
            for (int i = 0; i < CalculatorMappings.Count; ++i)
            {
                var mapping = CalculatorMappings.ElementAt(i);
                if (mapping.ParsingCalculatorID != null)
                {
                    var ref_candidate = Factory.ProjectData.IdGenerator.GetById<SimComponent>(mapping.ParsingCalculatorID);
                    if (ref_candidate != null)
                    {
                        mapping.Restore(this, ref_candidate);
                    }
                    else
                    {
                        //Target missing
                        CalculatorMappings_Internal.RemoveAt(i);
                        i--;
                    }
                }
            }

            //Restore instances
            Instances.ForEach(x => x.RestoreReferences(networkElements));

            //Assets
            assetManager.RestoreAssetsToComponent(this);

            //Call on child components
            foreach (var subComp in this.Components)
                subComp.Component?.RestoreReferences(networkElements, assetManager);
        }

        internal void RemoveAllAssets()
        {
            for (int i = 0; i < Instances.Count; ++i)
            {
                var instance = Instances[i];
                for (int j = 0; j < instance.Placements.Count; ++j)
                {
                    if (instance.Placements[j] is SimInstancePlacementGeometry)
                        Instances.RemoveAt(j);
                }

                if (instance.Placements.Count == 0)
                    Instances.RemoveAt(i);
            }

            foreach (var asset in ReferencedAssets)
                asset.RemoveReferencing(this.Id.LocalId);
            ReferencedAssets_Internal.Clear();

            foreach (var child in this.Components.Where(x => x != null))
                child.Component.RemoveAllAssets();
        }

        /// <summary>
        /// Executes all calculations in this component and in it's subcomponents in the correct order.
        /// Executes subcomponent calculations first, then calculations in the current component.
        /// </summary>
        /// <param name="tableNameProvider">A method which returns the name of newly created <see cref="SimMultiValueBigTable"/>s during
        /// a vector calculation. May be used to localize table names.</param>
        /// <param name="tableNameAverageProvider">A method which returns the name of newly created <see cref="SimMultiValueBigTable"/>s during
        /// the averaging of vector calculation results. May be used to localize table names.</param>
        /// <param name="parameterReplacements">A list of parameters which override the parameters used by default</param>
        /// <param name="valueFields">The value manager for executing vector calculations</param>
        /// <param name="dispatcher">The dispatcher in which UI operations should be performed</param>
        public void ExecuteAllCalculationChains(
            TableNameProviderDelegate tableNameProvider = null, TableNameProviderDelegate tableNameAverageProvider = null,
            Dictionary<SimParameter, SimParameter> parameterReplacements = null,
            SimMultiValueCollection valueFields = null, Dispatcher dispatcher = null)
        {
            foreach (var entry in Components)
            {
                SimComponent sC = entry.Component;
                if (sC != null)
                    sC.ExecuteAllCalculationChains(tableNameProvider, tableNameAverageProvider, parameterReplacements, valueFields, dispatcher);
            }

            // perform the calculations
            foreach (SimCalculation c in Calculations)
            {
                c.Calculate(valueFields,
                    tableNameProvider, tableNameAverageProvider,
                    parameterReplacements, dispatcher);
            }
        }
    }
}
