using SIMULTAN.Data.Assets;
using SIMULTAN.Data.FlowNetworks;
using SIMULTAN.Data.Geometry;
using SIMULTAN.Data.MultiValues;
using SIMULTAN.Data.Taxonomy;
using SIMULTAN.Data.Users;
using SIMULTAN.Exceptions;
using SIMULTAN.Utils;
using SIMULTAN.Utils.Collections;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq;
using System.Windows.Threading;
using static SIMULTAN.Data.Components.SimCalculation;

namespace SIMULTAN.Data.Components
{
    /// <summary>
    /// The main data model class. Serves as a named container which stores other objects like
    /// Parameters (<see cref="Parameters"/>), Calculations (<see cref="Calculations"/>).
    /// Components itself serve as a Type (in a OOP sense). Each component may have instances which describe
    /// a specific item of the component's type. For details about instances see the <see cref="SimComponentInstance"/> class.
    /// 
    /// Components provide a tree-like structure where subcomponents are found in <see cref="Components"/>.
    /// In addition to storing the subcomponent, the component also stores the which function the component has in the
    /// <see cref="SimChildComponentEntry.Slot"/> property.
    /// 
    /// Components can reference each other via <see cref="ReferencedComponents"/>/<see cref="ReferencedBy"/>.
    /// 
    /// Access management is provided by the <see cref="AccessLocal"/> property. Write access is enforced by the <see cref="NotifyWriteAccess"/> method
    /// which throws an <see cref="AccessDeniedException"/> when a user without write access tries to access the component. Details about access
    /// management can be found in the <see cref="SimAccessProfile"/>.
    /// </summary>
    [DebuggerDisplay("[Component] {Name}, Id = {Id}")]
    public partial class SimComponent : SimNamedObject<SimComponentCollection>
    {
        #region Properties

        /// <summary>
        /// Returns the category of the component. This is the combination of all child component categories together with the
        /// categories of all parameters (<see cref="SimBaseParameter.Category"/>)
        /// </summary>
        public SimCategory Category
        {
            get { return this.category; }
            private set
            {
                this.category = value;
                this.NotifyPropertyChanged(nameof(this.Category));
            }
        }
        private SimCategory category;

        /// <summary>
        /// Stores the access profile for each <see cref="SimUserRole"/> and saves last writing, supervising and publishing access per user type.
        /// </summary>
        public SimAccessProfile AccessLocal
        {
            get { return this.accessLocal; }
            set
            {
                if (this.accessLocal != null)
                {
                    this.accessLocal.Component = null;
                }

                this.accessLocal = value;

                if (this.accessLocal != null)
                {
                    this.accessLocal.Component = this;
                }

                this.NotifyPropertyChanged(nameof(this.AccessLocal));
                this.NotifyAccessChanged();
            }
        }
        private SimAccessProfile accessLocal;

        /// <summary>
        /// Stores the function which a component may be used. For top-level components the slot is free to choose.
        /// For child components, the slot has to match the <see cref="SimChildComponentEntry.Slot"/> property.
        /// </summary>
        public SimTaxonomyEntryReference CurrentSlot
        {
            get { return this.currentSlot; }
            set
            {
                if (currentSlot != value && (
                    (currentSlot == null && value != null) ||
                    this.currentSlot.Target != value.Target ||
                    currentSlot.TaxonomyEntryId != value.TaxonomyEntryId))
                {
                    this.RecordWriteAccess();

                    if (currentSlot != null)
                    {
                        CurrentSlot.RemoveDeleteAction();
                    }

                    this.currentSlot = value;

                    currentSlot.SetDeleteAction(CurrentSlotTaxonomyEntryDeleted);

                    if (this.ParentContainer != null)
                        this.ParentContainer.Slot = new SimSlot(new SimTaxonomyEntryReference(value), this.ParentContainer.Slot.SlotExtension);

                    this.NotifyPropertyChanged(nameof(this.CurrentSlot));
                    this.NotifyChanged();
                }
            }
        }
        private SimTaxonomyEntryReference currentSlot;

        /// <summary>
        /// Returns True when the component has been generated by some algorithm (everything else than a user).
        /// This property can be set at any time and doesn't impose any restrictions (other than those imposed by the UI).
        /// </summary>
        public bool IsAutomaticallyGenerated
        {
            get { return this.isAutomaticallyGenerated; }
            set
            {
                if (value != this.isAutomaticallyGenerated)
                {
                    this.NotifyWriteAccess();
                    this.isAutomaticallyGenerated = value;
                    this.NotifyPropertyChanged(nameof(this.IsAutomaticallyGenerated));
                    this.NotifyChanged();
                }
            }
        }
        private bool isAutomaticallyGenerated;

        /// <summary>
        /// Stores the container in which the component is placed.
        /// This property is set automatically when the component is added to a <see cref="Components"/> collection.
        /// Returns null when the component is a top-level element.
        /// </summary>
        public SimChildComponentEntry ParentContainer { get; internal set; }

        /// <summary>
        /// Returns the parent component, or Null when no parent exists
        /// </summary>
        public SimComponent Parent { get { return this.ParentContainer?.Parent; } }

        /// <summary>
        /// Stores in which way child components should be sorted. This property is only used by the UI but is persisted in the data model.
        /// </summary>
        public SimComponentContentSorting SortingType
        {
            get { return this.sorting_type; }
            set
            {
                if (this.sorting_type != value)
                {
                    this.NotifyWriteAccess();
                    this.sorting_type = value;
                    this.NotifyPropertyChanged(nameof(this.SortingType));
                    this.NotifyChanged();
                }
            }
        }
        private SimComponentContentSorting sorting_type = SimComponentContentSorting.ByName;

        /// <summary>
        /// The visibility of the component within and beyond a project.
        /// </summary>
        public SimComponentVisibility Visibility
        {
            get { return this.visibility; }
            set
            {
                if (this.visibility != value)
                {
                    this.NotifyWriteAccess();
                    this.visibility = value;
                    this.NotifyPropertyChanged(nameof(this.Visibility));
                    this.NotifyChanged();
                }
            }
        }
        private SimComponentVisibility visibility;

        /// <summary>
        /// The color of the component in a GUI.
        /// </summary>
        public System.Windows.Media.Color ComponentColor
        {
            get { return this.componentColor; }
            set
            {
                if (this.componentColor != value)
                {
                    this.NotifyWriteAccess();
                    this.componentColor = value;
                    this.NotifyPropertyChanged(nameof(this.ComponentColor));
                    this.NotifyChanged();
                }
            }
        }
        private System.Windows.Media.Color componentColor;

        #endregion

        #region Contained Elements

        /// <summary>
        /// Stores the child components of this component. Users need write access to the current component in order to modify this collection.
        /// </summary>
        public SimChildComponentCollection Components { get; }

        /// <summary>
        /// Stores the parameters in the component
        /// </summary>
        public SimParameterCollection Parameters { get; }

        /// <summary>
        /// All calculations contained in this component. They can select parameters for in- and output
        /// only from the ones contained in this component or any of its sub-components. The order of the 
        /// calculations in the list corresponds to the sequence in which they have to be performed and is 
        /// automatically updated after adding, deleting or editing a calculation or a parameter.
        /// </summary>
        public SimCalculationCollection Calculations { get; }

        /// <summary>
        /// A list of all components referenced by this one. See <see cref="SimComponentReference"/> for more details
        /// </summary>
        public SimReferenceCollection ReferencedComponents { get; }
        /// <summary>
        /// A list of all components that reference the current one. Automatically generated from the <see cref="ReferencedComponents"/> collection
        /// </summary>
        public IReadOnlyList<SimComponentReference> ReferencedBy { get { return this.ReferencedBy_Internal; } }
        /// <summary>
        /// A list of all components that reference the current one. Automatically generated from the <see cref="ReferencedComponents"/> collection
        /// </summary>
        internal List<SimComponentReference> ReferencedBy_Internal { get; }

        /// <summary>
        /// A sequence of chat items (questions, answers, reactions, votes etc.).
        /// Represents the decision history of a component.
        /// </summary>
        public SimChat Conversation
        {
            get { return this.conversation; }
            internal set
            {
                this.conversation = value;
            }
        }
        private SimChat conversation;

        /// <summary>
        /// A list of assets used by this component. The list is not saved but reconstructed from the 
        /// saved asset manager after loading. Assets can be documents, geometry, etc. Changes are tracked in the <see cref="AssetManager"/>.
        /// </summary>
        public ReadOnlyObservableCollection<Asset> ReferencedAssets { get { return this.referencedAssetsReadonly; } }

        /// <summary>
        /// A list of assets used by this component. The list is not saved but reconstructed from the 
        /// saved asset manager after loading. Assets can be documents, geometry, etc. Changes are tracked in the <see cref="AssetManager"/>.
        /// </summary>
        internal ObservableCollection<Asset> ReferencedAssets_Internal
        {
            get { return this.referencedAssets; }
            private set
            {
                this.referencedAssets = value;
                this.referencedAssetsReadonly = new ReadOnlyObservableCollection<Asset>(this.referencedAssets);
                this.NotifyPropertyChanged(nameof(this.ReferencedAssets_Internal));
                this.NotifyPropertyChanged(nameof(this.ReferencedAssets));
            }
        }
        private ObservableCollection<Asset> referencedAssets;
        private ReadOnlyObservableCollection<Asset> referencedAssetsReadonly;

        #endregion

        #region Instances

        /// <summary>
        /// Stores the type of instance this component supports.
        /// </summary>
        public SimInstanceType InstanceType
        {
            get { return this.instanceType; }
            set
            {
                if (this.Instances.Count > 0)
                    throw new InvalidOperationException("Operation is only possible when no instances exist");

                if (this.instanceType != value)
                {
                    this.NotifyWriteAccess();
                    this.instanceType = value;
                    this.NotifyPropertyChanged(nameof(this.InstanceType));
                    this.NotifyChanged();
                }
            }
        }
        private SimInstanceType instanceType = SimInstanceType.None;

        /// <summary>
        /// Stores the instances of this component. Details about instances can be found in <see cref="SimComponentInstance"/>.
        /// </summary>
        public SimInstanceCollection Instances { get; }

        /// <summary>
        /// Reflects the state of the instances. Combined information collected from all instances.
        /// </summary>
        public SimInstanceState InstanceState
        {
            get { return this.instanceState; }
            private set
            {
                if (this.instanceState != value)
                {
                    this.instanceState = value;
                    this.NotifyPropertyChanged(nameof(this.InstanceState));
                }
            }
        }
        private SimInstanceState instanceState = new SimInstanceState();

        /// <summary>
        /// Returns true when at least on instance is bound to a network
        /// </summary>
        public bool IsBoundInNetwork
        {
            get { return this.isBoundInNetwork; }
            protected set
            {
                if (this.isBoundInNetwork != value)
                {
                    this.isBoundInNetwork = value;
                    this.NotifyPropertyChanged(nameof(this.IsBoundInNetwork));
                }
            }
        }
        private bool isBoundInNetwork;

        /// <summary>
        /// Returns true when at least on instance is bound to a SimNetwork
        /// </summary>
        public bool IsBoundInSimNetwork
        {
            get { return this.isBoundInSimNetwork; }
            protected set
            {
                if (this.isBoundInSimNetwork != value)
                {
                    this.isBoundInSimNetwork = value;
                    this.NotifyPropertyChanged(nameof(this.IsBoundInSimNetwork));
                }
            }
        }
        private bool isBoundInSimNetwork;

        /// <summary>
        /// Notifies the component that one of it's instances has changed a property that affects the instance state
        /// </summary>
        internal void OnInstanceStateChanged()
        {
            bool isInNetwork = false;
            bool isRealized = false;
            bool isInSimNW = false;
            bool isBoundInSimNetwork = false;
            SimInstanceConnectionState state = SimInstanceConnectionState.Ok;

            foreach (var instance in this.Instances)
            {
                isInNetwork |= instance.Placements.Any(x => x is SimInstancePlacementNetwork);
                isRealized |= instance.State.IsRealized;
                isInSimNW |= instance.Placements.Any(x => x is SimInstancePlacementSimNetwork);
                var simNWInstance = instance.Placements.FirstOrDefault(x => x is SimInstancePlacementSimNetwork) as SimInstancePlacementSimNetwork;
                if (simNWInstance != null)
                {
                    isBoundInSimNetwork = true;
                }

                if (instance.State.ConnectionState != SimInstanceConnectionState.Ok)
                    state = instance.State.ConnectionState;
            }

            this.InstanceState = new SimInstanceState(isRealized, state);
            this.IsBoundInNetwork = isInNetwork;
            this.IsBoundInSimNetwork = isBoundInSimNetwork;
            this.IsBoundInSimNetwork = isInSimNW;

            foreach (var parameter in Parameters)
            {
                if (parameter.ValueSource != null && parameter.ValueSource is SimGeometryParameterSource source)
                {
                    source.UpdateAllInstanceFilters();
                }
            }
        }
        #endregion


        #region Mappings

        /// <summary>
        /// A list of mappings to other components that can be used by this one as calculators. This allows to reuse
        /// calculation sequences defined in another component an arbitrary number of times.
		/// This property is only set by the constructors
        /// </summary>
        public IReadOnlyObservableCollection<CalculatorMapping> CalculatorMappings
        {
            get { return this.calculatorMappings; }
        }
        internal ElectivelyObservableCollection<CalculatorMapping> CalculatorMappings_Internal
        {
            get { return this.calculatorMappings; }
            private set
            {
                if (this.calculatorMappings != null)
                    throw new NotSupportedException("This property may only be set once");

                this.calculatorMappings = value;
            }
        }
        private ElectivelyObservableCollection<CalculatorMapping> calculatorMappings;

        /// <summary>
        /// Derived: A list of all components that use this one as a calculator.
        /// </summary>
        public List<SimComponent> MappedToBy { get; private set; }

        #endregion

        #region Events

        /// <summary>
        /// Handler for the IsBeingDelted event.
        /// </summary>
        /// <param name="sender"></param>
        public delegate void IsBeingDeletedEventHandler(object sender);
        /// <summary>
        /// Emitted just before the component is being deleted.
        /// </summary>
        public event IsBeingDeletedEventHandler IsBeingDeleted;
        /// <summary>
        /// Emits the IsBeingDelted event.
        /// </summary>
        public void OnIsBeingDeleted()
        {
            this.IsBeingDeleted?.Invoke(this);

            foreach (var entry in this.Components)
            {
                entry?.Component?.OnIsBeingDeleted();
            }
        }



        /// <summary>
        /// Invoked when the access rules have been changed. E.g. when <see cref="AccessLocal"/> is changed or when the
        /// access rights inside the <see cref="SimAccessProfile"/> are modified.
        /// </summary>
        public event EventHandler AccessChanged;
        /// <summary>
        /// Invokes the <see cref="AccessChanged"/> event
        /// </summary>
        internal void NotifyAccessChanged()
        {
            this.AccessChanged?.Invoke(this, EventArgs.Empty);
        }

        #endregion


        /// <summary>
        /// Initializes a new, empty instance of the Component class.
        /// Same as calling <see cref="SimComponent(SimUserRole)"/> with the <see cref="SimUserRole.ADMINISTRATOR"/>
        /// </summary>
        public SimComponent() : this(SimUserRole.ADMINISTRATOR) { }

        /// <summary>
        /// Initializes a new, empty instance of the Component class.
        /// </summary>
        /// <param name="owner">The user which has write access</param>
        public SimComponent(SimUserRole owner)
        {
            // contained entities
            this.Components = new SimChildComponentCollection(this);
            this.Parameters = new SimParameterCollection(this);
            this.Calculations = new SimCalculationCollection(this);

            this.ReferencedBy_Internal = new List<SimComponentReference>();
            this.ReferencedComponents = new SimReferenceCollection(this);

            // geometry (default state: NONE)
            this.Instances = new SimInstanceCollection(this);

            // general
            this.Id = SimId.Empty;
            this.Name = string.Empty;
            this.Description = string.Empty;

            // management
            this.Category = SimCategory.None;
            this.AccessLocal = new SimAccessProfile(owner);
            this.CurrentSlot = null;

            // factory properties
            this.Factory = null;

            // mapping for calculations
            this.CalculatorMappings_Internal = new ElectivelyObservableCollection<CalculatorMapping>();
            this.MappedToBy = new List<SimComponent>();

            // assets
            this.ReferencedAssets_Internal = new ObservableCollection<Asset>();
            // conversation
            this.Conversation = new SimChat();

            // project
            this.Visibility = SimComponentVisibility.VisibleInProject;
            this.ComponentColor = System.Windows.Media.Color.FromArgb(255, 0, 255, 0);
            this.sorting_type = SimComponentContentSorting.ByName;
        }

        /// <summary>
        /// Initializes a new instance of the Component class by copying all data recursively from another component
        /// References are rebound to the copied ones when the reference points to the copied subtree.
        /// </summary>
        /// <param name="original">The component to copy from</param>
        public SimComponent(SimComponent original)
        {
            if (original == null)
                throw new ArgumentNullException(nameof(original));

            this.Instances = new SimInstanceCollection(this);
            this.Components = new SimChildComponentCollection(this);
            this.Parameters = new SimParameterCollection(this);
            this.Calculations = new SimCalculationCollection(this);

            this.ReferencedBy_Internal = new List<SimComponentReference>();
            this.ReferencedComponents = new SimReferenceCollection(this);

            var parameterCopyRecord = new Dictionary<SimBaseParameter, SimBaseParameter>();
            var componentCopyRecord = new Dictionary<SimComponent, SimComponent>();

            this.CopyConstructorInit(original, parameterCopyRecord, componentCopyRecord);

            //Rebind references
            this.RebindReferences(this, componentCopyRecord);
        }

        private SimComponent(SimComponent _original, Dictionary<SimBaseParameter, SimBaseParameter> parameterCopyRecord, Dictionary<SimComponent, SimComponent> componentCopyRecord)
        {
            this.Instances = new SimInstanceCollection(this);
            this.Components = new SimChildComponentCollection(this);
            this.Parameters = new SimParameterCollection(this);
            this.Calculations = new SimCalculationCollection(this);

            this.ReferencedBy_Internal = new List<SimComponentReference>();
            this.ReferencedComponents = new SimReferenceCollection(this);

            this.CopyConstructorInit(_original, parameterCopyRecord, componentCopyRecord);
        }

        /// <summary>
        /// Initializes a new instance of the Component class. Used for parsing components from a DXF file
        /// </summary>
        /// <remarks>
        /// Does NOT restore referenced components immediately.
        /// The component factory attempts to restore the references WHEN ALL COMPONENTS HAVE BEEN PARSED
        /// </remarks>
        /// <param name="globalId">The global id of the component</param>
        /// <param name="localId">The local id of the component</param>
        /// <param name="name">The name of the component</param>
        /// <param name="description">A description text</param>
        /// <param name="isAutomaticallyGenerated">When set to True, the component is marked as being automatically created</param>
        /// <param name="accessLocal">The access profile for this component</param>
        /// <param name="currentSlot">The slot base for this component</param>
        /// <param name="components">A list of all child components together with their full slot</param>
        /// <param name="referencedComponents">
        /// A list of all referenced components. This data is temporarily stored and references are restored when
        /// calling <see cref="RestoreReferences(Dictionary{SimObjectId, SimFlowNetworkElement}, AssetManager)"/>
        /// </param>
        /// <param name="parameters">All parameters contained in this component</param>
        /// <param name="calculations">Initialization data for the calculations in this component. References to parameters are restored here.</param>
        /// <param name="instanceType">The instance type of this component</param>
        /// <param name="instances">The instances of this component</param>
        /// <param name="calculatorMappings">All mappings to calculator components</param>
        /// <param name="chat">The chat items of this component</param>
        /// <param name="visibility">The visibility of this component inside the project</param>
        /// <param name="color">The display color of this component</param>
        /// <param name="sorting">Specifies how child components should be sorted in the UI</param>
        internal SimComponent(Guid globalId, long localId, string name, string description, bool isAutomaticallyGenerated,
                           SimAccessProfile accessLocal, SimTaxonomyEntryReference currentSlot,
                           IEnumerable<(SimSlot slot, SimComponent component)> components,
                           IEnumerable<SimComponentReference> referencedComponents,
                           IEnumerable<SimBaseParameter> parameters, IEnumerable<CalculationInitializationData> calculations,
                           SimInstanceType instanceType, IEnumerable<SimComponentInstance> instances, IEnumerable<CalculatorMapping> calculatorMappings,
                           IEnumerable<SimChatItem> chat, SimComponentVisibility visibility, System.Windows.Media.Color color,
                           SimComponentContentSorting sorting)
        {
            this.Instances = new SimInstanceCollection(this);
            this.InstanceType = instanceType;

            // general
            this.Id = new SimId(globalId, localId);
            this.Name = name;
            this.Description = description;
            this.IsAutomaticallyGenerated = isAutomaticallyGenerated;

            // MANAGEMENT 1 - TMP (for usage during the filling in of parameters and subcomponents)
            this.Category = SimCategory.None;
            this.AccessLocal = new SimAccessProfile(SimUserRole.ADMINISTRATOR);

            // CONTAINED ENTITIES
            // // -- SubComponents (do NOT copy!)
            this.Components = new SimChildComponentCollection(this);
            foreach (var entry in components)
            {
                this.Components.Add(new SimChildComponentEntry(entry.slot, entry.component));
            }

            // // -- referenced Components (just prepare containers)
            this.ReferencedBy_Internal = new List<SimComponentReference>();
            this.ReferencedComponents = new SimReferenceCollection(this);
            foreach (var entry in referencedComponents)
                this.ReferencedComponents.Add(entry);

            // // -- Contained Parameters (do NOT copy!)
            this.Parameters = new SimParameterCollection(this);
            foreach (var p in parameters)
                this.Parameters.Add(p);

            // // -- Contained Calculations in the correct order
            // // -- assumes that the calculation was correctly saved!
            this.Calculations = new SimCalculationCollection(this);

            var flat_parameters = ComponentWalker.GetFlatParameters(this).ToDictionary(x => x.Id.LocalId, x => x);
            foreach (CalculationInitializationData calcP in calculations)
            {
                // compose the actual parameter lists
                Dictionary<string, SimDoubleParameter> parameters_in = new Dictionary<string, SimDoubleParameter>();
                foreach (var entry in calcP.InputParameters)
                {
                    if (entry.Value != SimId.Empty && entry.Value.GlobalId != globalId)
                        throw new NotSupportedException("References to parameters from other projects are not supported");

                    if (entry.Value != SimId.Empty && flat_parameters.TryGetValue(entry.Value.LocalId, out var param) && param is SimDoubleParameter doubleParam)
                        parameters_in.Add(entry.Key, doubleParam);
                    else
                        parameters_in.Add(entry.Key, null);
                }

                Dictionary<string, SimDoubleParameter> parameters_out = new Dictionary<string, SimDoubleParameter>();
                foreach (var entry in calcP.ReturnParameters)
                {
                    if (entry.Value != SimId.Empty && entry.Value.GlobalId != globalId)
                        throw new NotSupportedException("References to parameters from other projects are not supported");

                    if (entry.Value != SimId.Empty && flat_parameters.TryGetValue(entry.Value.LocalId, out var param) && param is SimDoubleParameter doubleParam)
                        parameters_out.Add(entry.Key, doubleParam);
                    else
                        parameters_out.Add(entry.Key, null);
                }
                // re-construct the calculation
                SimCalculation calc = new SimCalculation(calcP.LocalID, calcP.Expression, calcP.Name, parameters_in, parameters_out,
                    calcP.MetaData, calcP.VectorOperationList,
                    calcP.NrExecutions, calcP.OverrideVectorResult,
                    calcP.AggregationMethod);
                this.Calculations.Add(calc);
            }

            // MANAGEMENT 2 (overrides the changes made during the filling in of parameters and subcomponents)
            this.GatherCategoryInfo();
            this.AccessLocal = accessLocal; // AFTER 'FitsInSlots' in order to adopt user changes made after the slot selection
            this.CurrentSlot = currentSlot;

            // geometry
            foreach (SimComponentInstance gr in instances)
            {
                this.Instances.Add(gr);
            }

            // mapping to calculations
            this.CalculatorMappings_Internal = new ElectivelyObservableCollection<CalculatorMapping>(calculatorMappings);
            this.MappedToBy = new List<SimComponent>();

            // assets are added in a post-processing step
            this.ReferencedAssets_Internal = new ObservableCollection<Asset>();

            // the conversation
            this.Conversation = new SimChat(chat);

            // project-relevant
            this.Visibility = visibility;
            this.ComponentColor = color;

            // view-relevant
            this.SortingType = sorting;
        }


        #region Ctor Helper

        private void CopyConstructorInit(SimComponent _original, Dictionary<SimBaseParameter, SimBaseParameter> parameterCopyRecord, Dictionary<SimComponent, SimComponent> componentCopyRecord)
        {
            componentCopyRecord.Add(_original, this);

            this.InstanceType = _original.InstanceType;

            // general

            this.Id = SimId.Empty;
            this.Factory = null;

            this.Name = _original.Name;
            this.Description = _original.Description;
            this.IsAutomaticallyGenerated = _original.IsAutomaticallyGenerated;

            this.Visibility = _original.Visibility;
            this.ComponentColor = _original.ComponentColor;
            this.SortingType = _original.SortingType;

            this.Category = SimCategory.None;
            this.AccessLocal = new SimAccessProfile(_original.AccessLocal);
            this.CurrentSlot = new SimTaxonomyEntryReference(_original.CurrentSlot);

            // SubComponents
            foreach (var entry in _original.Components)
            {
                SimComponent c = entry.Component;
                if (c != null)
                {
                    if (c.IsAutomaticallyGenerated) continue;

                    SimComponent c_copy = new SimComponent(c, parameterCopyRecord, componentCopyRecord);
                    this.Components.Add(new SimChildComponentEntry(new SimSlot(entry.Slot), c_copy));
                }
                else
                    this.Components.Add(new SimChildComponentEntry(new SimSlot(entry.Slot)));
            }

            // References
            foreach (var entry in _original.ReferencedComponents)
            {
                var target = entry.Target;

                //This is not exactly necessary (since RebindReferences has to be called after all constructors anyway),
                //but it improves performance to do it here too.
                if (target != null && componentCopyRecord.TryGetValue(target, out var copiedTarget))
                    target = copiedTarget;

                //this.AddReferencedComponent(slot_cp, target);
                this.ReferencedComponents.Add(new SimComponentReference(new SimSlot(entry.Slot), target));
            }

            // Parameters
            foreach (var p_orig in _original.Parameters)
            {
                if (p_orig != null)
                {
                    SimBaseParameter p_copy = p_orig.Clone();
                    this.Parameters.Add(p_copy);
                    parameterCopyRecord.Add(p_orig, p_copy);
                }
            }

            // Calculations
            foreach (SimCalculation calc in _original.Calculations)
            {
                SimCalculation calc_copy = new SimCalculation(calc);

                foreach (var entry in calc.InputParams.ToList())
                {
                    if (entry.Value != null)
                    {
                        if (parameterCopyRecord.TryGetValue(entry.Value, out var newTarget) && newTarget is SimDoubleParameter doubleTarget)
                            calc_copy.InputParams[entry.Key] = doubleTarget;
                        else
                            calc_copy.InputParams[entry.Key] = null;
                    }
                }
                foreach (var entry in calc.ReturnParams.ToList())
                {
                    if (entry.Value != null)
                    {
                        if (parameterCopyRecord.TryGetValue(entry.Value, out var newTarget) && newTarget is SimDoubleParameter doubleTarget)
                            calc_copy.ReturnParams[entry.Key] = doubleTarget;
                        else
                            calc_copy.ReturnParams[entry.Key] = null;
                    }
                }
                this.Calculations.Add(calc_copy);
            }

            // MANAGEMENT 2 (overrides the changes made during the filling in of parameters and subcomponents)
            this.Category = _original.Category;

            // mapping for calculations -> copy them
            this.CalculatorMappings_Internal = new ElectivelyObservableCollection<CalculatorMapping>();
            foreach (CalculatorMapping m in _original.CalculatorMappings)
            {
                var doubles = parameterCopyRecord.Where(t => t.Value is SimDoubleParameter && t.Key is SimDoubleParameter) as Dictionary<SimDoubleParameter, SimDoubleParameter>;
                CalculatorMapping m_copy = m.ExchangeDataParameter(doubles);
                if (m_copy != null)
                {
                    this.CalculatorMappings_Internal.Add(m_copy);
                    m_copy.Calculator.MappedToBy.Add(this);
                }
            }
            this.MappedToBy = new List<SimComponent>();

            // assets -> do not copy
            this.ReferencedAssets_Internal = new ObservableCollection<Asset>();
            // conversation -> do not copy
            this.Conversation = new SimChat();
        }

        private void RebindReferences(SimComponent component, Dictionary<SimComponent, SimComponent> componentCopyRecord)
        {
            foreach (var reference in component.ReferencedComponents.ToList())
            {
                if (reference.Target != null && componentCopyRecord.TryGetValue(reference.Target, out var newTarget))
                {
                    reference.Target = newTarget;
                }
            }

            foreach (var child in component.Components.Where(x => x.Component != null))
                this.RebindReferences(child.Component, componentCopyRecord);
        }

        #endregion

        #region METHODS: local access management

        /// <summary>
        /// Returns true when the user has the given access right
        /// </summary>
        /// <param name="user">The user</param>
        /// <param name="accessType">The access type that should be checked</param>
        /// <returns></returns>
        public bool HasAccess(SimUser user, SimComponentAccessPrivilege accessType)
        {
            if (accessType == SimComponentAccessPrivilege.Read && this.Visibility == SimComponentVisibility.AlwaysVisible)
                return true;

            if (user == null)
                return false;
            return this.AccessLocal[user.Role].Access.HasFlag(accessType);
        }
        /// <summary>
        /// Returns true when the user has the given access right on this component and on all subcomponents
        /// </summary>
        /// <param name="user">The user</param>
        /// <param name="accessType">The access type that should be checked</param>
        /// <returns></returns>
        public bool HasSubtreeAccess(SimUser user, SimComponentAccessPrivilege accessType)
        {
            if (!this.HasAccess(user, accessType))
                return false;

            return this.Components.All(x => x.Component == null || x.Component.HasSubtreeAccess(user, accessType));
        }

        /// <summary>
        /// Notifies the component about a write access.
        /// Throws an <see cref="AccessDeniedException"/> when the user doesn't have write access to the component.
        /// The write access is recorded in the <see cref="SimComponent.AccessLocal"/>
        /// </summary>
        internal void RecordWriteAccess()
        {
            if (this.Factory != null && this.Factory.EnableAccessChecking && this.Factory.ProjectData.UsersManager != null)
            {
                if (this.Factory.ProjectData.UsersManager.CurrentUser == null)
                    throw new AccessDeniedException();

                var role = this.Factory.ProjectData.UsersManager.CurrentUser.Role;
                SimAccessProfileEntry tracker = this.AccessLocal[role];
                if (!(tracker.Access.HasFlag(SimComponentAccessPrivilege.Write)))
                    throw new AccessDeniedException();

                // record the access
                tracker.LastAccessWrite = DateTime.Now;
            }
        }

        /// <inheritdoc/>
        protected override void NotifyWriteAccess()
        {
            this.RecordWriteAccess();
            base.NotifyWriteAccess();
        }

        /// <summary>
        /// Records a write access no matter if the user has write access. 
        /// This is necessary, for example, when a whole subtree is added since subtree children might not have the same access rights as the parent
        /// 
        /// When <see cref="SimComponentCollection.EnableAccessChecking"/> is False, no access is recorded
        /// </summary>
        /// <param name="user">The user for which the write access should be set</param>
        internal void ForceRecordWriteAccess(SimUser user)
        {
            if (this.Factory == null || this.Factory.EnableAccessChecking)
            {
                SimAccessProfileEntry tracker = this.AccessLocal[user.Role];
                tracker.ForceSetWriteAccess(user, DateTime.Now);
            }
        }

        #endregion

        #region METHODS: To String

        [Obsolete]
        public override string ToString()
        {
            string output = "";
            output += " " + this.Id + ": " + this.Name + "( " + this.Description + " ) ";
            output += "sub-comp {" + this.Components.Count + "} ";
            output += "ref-comp {" + this.ReferencedComponents.Count + "} ";
            output += "params {" + this.Parameters.Count + "}";

            return output;
        }

        /// <summary>
        /// A string containing the component's id, name, description and current slot.
        /// </summary>
        /// <returns></returns>
        [Obsolete]
        public string ToInfoString()
        {
            return this.CurrentSlot + ": {" + this.LocalID + "}" + this.Name + " - " + this.Description;
        }

        #endregion

        #region Contained object data propagation

        private void ReactToParameterPropagationChanged(SimBaseParameter p)
        {
            var comp = this;

            bool foundMin = false, foundMax = false;
            bool foundValue = false;


            //Adapt value only when a reference parameter and when no MVpointer is attached
            if (p.Propagation != SimInfoFlow.FromReference)
                return;

            if (p.ValueSource != null)
            {
                return;
            }

            //Find and update the closest parameter which matches the name
            while (comp != null)
            {
                foreach (var entry in comp.ReferencedComponents)
                {
                    if (entry.Target != null)
                    {
                        foreach (var rP in ComponentWalker.GetFlatParameters(entry.Target))
                        {
                            if (rP.NameTaxonomyEntry.Name != null)
                            {
                                if (!foundValue && rP.NameTaxonomyEntry.Equals(p.NameTaxonomyEntry))
                                {
                                    if (p is SimDoubleParameter pDouble && rP is SimDoubleParameter rpDouble)
                                    {
                                        pDouble.Value = rpDouble.Value;
                                        p.Description = rP.Description;
                                        foundValue = true;
                                        if (!foundMin
                                                && rP.NameTaxonomyEntry.Name.EndsWith("MIN"))
                                        {
                                            pDouble.ValueMin = rpDouble.Value;
                                            foundMin = true;
                                        }
                                        else if (!foundMax && rP.NameTaxonomyEntry.Name.EndsWith("MAX"))
                                        {
                                            pDouble.ValueMax = rpDouble.Value;
                                            foundMax = true;
                                        }
                                    }
                                    else if (p is SimIntegerParameter iParam && rP is SimIntegerParameter siParam)
                                    {
                                        iParam.Value = siParam.Value;
                                        p.Description = rP.Description;
                                        foundValue = true;
                                        if (!foundMin
                                                && rP.NameTaxonomyEntry.Name.EndsWith("MIN"))
                                        {
                                            iParam.ValueMin = siParam.Value;
                                            foundMin = true;
                                        }
                                        else if (!foundMax && rP.NameTaxonomyEntry.Name.EndsWith("MAX"))
                                        {
                                            iParam.ValueMax = siParam.Value;
                                            foundMax = true;
                                        }
                                    }
                                    else if (p is SimStringParameter sParam && rP is SimStringParameter rsParam)
                                    {
                                        sParam.Value = rsParam.Value;
                                        p.Description = rP.Description;
                                        foundValue = true;
                                    }
                                    else if (p is SimBoolParameter bParam && rP is SimBoolParameter rbParam)
                                    {
                                        bParam.Value = rbParam.Value;
                                        p.Description = rP.Description;
                                        foundValue = true;
                                    }
                                    else if (p is SimEnumParameter eParam && rP is SimEnumParameter ebParam)
                                    {
                                        if (ebParam.Value != null)
                                        {
                                            eParam.Value = new SimTaxonomyEntryReference(ebParam.Value.Target);
                                        }
                                        else
                                        {
                                            eParam.Value = null;
                                        }

                                        p.Description = rP.Description;
                                        foundValue = true;
                                    }
                                    else
                                    {
                                        throw new NotImplementedException(p.GetType().ToString());
                                    }

                                }

                            }
                            //Early exit when all references are found
                            if (foundValue && foundMin && foundMax)
                                return;
                        }
                    }
                }
                comp = comp.Parent;
            }

        }

        internal void OnParameterValueChanged(SimBaseParameter p)
        {
            // propagate info to all components that reference this one
            this.PropagateRefParamValueFromClosestRef(p);
            // update all instances
            this.Instances?.OnParameterValueChanged(p);
        }

        /// <inheritdoc />
        protected override void OnFactoryChanged(SimComponentCollection newFactory, SimComponentCollection oldFactory)
        {
            //Update calculation Ids
            this.Calculations.NotifyFactoryChanged(this.Factory, oldFactory);
            this.Parameters.NotifyFactoryChanged(this.Factory, oldFactory);
            this.Instances.NotifyFactoryChanged(this.Factory, oldFactory);

            this.Components.NotifyFactoryChanged(this.Factory, oldFactory);
            this.ReferencedComponents.NotifyFactoryChanged(this.Factory, oldFactory);

            base.OnFactoryChanged(newFactory, oldFactory);
        }

        /// <summary>
        /// Sets the category of the component as an aggregation of the categories 
        /// of its parameters and sub-components.
        /// </summary>
        private void GatherCategoryInfo()
        {
            SimCategory newC = SimCategory.None;
            foreach (var entry in this.Components.Where(x => x.Component != null))
            {
                newC |= entry.Component.Category;
            }
            foreach (var entry in this.Parameters)
            {
                newC |= entry.Category;
            }
            this.Category = newC;
        }

        #endregion


        /// <summary>
        /// Looks up taxonomy entries for default slot by their name.
        /// Do this if the default taxonomies changed, could mean that the project is migrated.
        /// </summary>
        /// <exception cref="Exception">If the default taxonomy entry could not be found.</exception>
        public void RestoreDefaultTaxonomyReferences(ulong taxonomyFileVersion)
        {
            if (currentSlot is SimPlaceholderTaxonomyEntryReference placeholder)
            {
                var entry = ResolvePlaceholderTaxonomyEntryReference(placeholder);
                if (ParentContainer != null)
                {
                    // also sets the current slot of the component
                    ParentContainer.Slot = new SimSlot(new SimTaxonomyEntryReference(entry), ParentContainer.Slot.SlotExtension);
                }
                else
                {
                    CurrentSlot = new SimTaxonomyEntryReference(entry);
                }
            }

            foreach (var reference in ReferencedComponents)
            {
                if (reference.Slot.SlotBase is SimPlaceholderTaxonomyEntryReference ph)
                {
                    var entry = ResolvePlaceholderTaxonomyEntryReference(ph);
                    reference.Slot = new SimSlot(new SimTaxonomyEntryReference(entry), reference.Slot.SlotExtension);
                }
            }

            foreach (var parameter in Parameters)
            {
                parameter.RestoreDefaultTaxonomyReferences(taxonomyFileVersion);
            }

            foreach (var child in Components)
            {
                if (child.Component != null)
                {
                    child.Component.RestoreDefaultTaxonomyReferences(taxonomyFileVersion);
                }
                else
                {
                    if (child.Slot.SlotBase is SimPlaceholderTaxonomyEntryReference cph)
                    {
                        var entry = ResolvePlaceholderTaxonomyEntryReference(cph);
                        child.Slot = new SimSlot(entry, child.Slot.SlotExtension);
                    }
                }
            }

        }

        private SimTaxonomyEntry ResolvePlaceholderTaxonomyEntryReference(SimPlaceholderTaxonomyEntryReference placeholder)
        {
            if (SimDefaultSlotKeys.BaseToKeyLookup.TryGetValue(placeholder.PlaceholderName, out var key))
            {
                var entry = GetDefaultSlotTaxonomyEntry(key);
                if (entry != null)
                {
                    return entry;
                }
                else
                {
                    throw new Exception(String.Format("Could not find default slot taxonomy entry with key {0}", key));
                }
            }
            else
            {
                throw new Exception(String.Format("Could not find default slot taxonomy entry with name {0}", placeholder.PlaceholderName));
            }
        }

        internal SimTaxonomyEntry GetDefaultSlotTaxonomyEntry(String key)
        {
            var taxonomy = Factory.ProjectData.Taxonomies.GetTaxonomyByKeyOrName(SimDefaultSlotKeys.TaxonomyKey);
            return taxonomy.GetTaxonomyEntryByKey(key);
        }

        private void CurrentSlotTaxonomyEntryDeleted(SimTaxonomyEntry caller)
        {
            // if we have a parent container, it'll take care of replacing the slot
            if (ParentContainer == null && Factory != null)
            {
                var undefinedTax = GetDefaultSlotTaxonomyEntry(SimDefaultSlotKeys.Undefined);
                CurrentSlot = new SimTaxonomyEntryReference(undefinedTax);
            }
        }

        /// <summary>
        /// Restores the references to other objects in the project after loading. This method needs to be called when all objects have been create and registered
        /// in their appropriate factories. Especially, this method may only be called when ALL components have been created.
        /// Restores referenced components, asset references, objects referenced by instances and calculator mappings.
        /// The method calls itself recursively for all child components.
        /// </summary>
        /// <param name="networkElements">A list of all network elements. This parameter will be obsolete when network elements are registered in the IdGenerator</param>
        /// <param name="assetManager">The asset manager in this project</param>
        public void RestoreReferences(Dictionary<SimObjectId, SimFlowNetworkElement> networkElements, AssetManager assetManager)
        {
            if (this.Factory == null)
                throw new InvalidOperationException("May only be called on components which are part of a factory");

            // Restore slot taxonomy entry references
            if (!(CurrentSlot is SimPlaceholderTaxonomyEntryReference))
            {
                // if it has a parent, use its slot base directly, otherwise look up the taxonomy entry
                if (ParentContainer != null)
                {
                    this.CurrentSlot = new SimTaxonomyEntryReference(ParentContainer.Slot.SlotBase);
                }
                else
                {
                    var entry = Factory.ProjectData.IdGenerator.GetById<SimTaxonomyEntry>(CurrentSlot.TaxonomyEntryId);
                    if (entry == null)
                        throw new TaxonomyEntryNotFoundException(String.Format("Taxonomy entry with id {0} of component {1} current slot could not be found", CurrentSlot.TaxonomyEntryId, this.ToString()));
                    this.CurrentSlot = new SimTaxonomyEntryReference(entry);
                }
            }

            //Restore component references
            this.ReferencedComponents.ForEach(x => x.RestoreReferences());

            //Restore calculator mappings
            for (int i = 0; i < this.CalculatorMappings.Count; ++i)
            {
                var mapping = CalculatorMappings_Internal[i];
                mapping.RestoreReferences(this);

                if (mapping.Calculator == null)
                {
                    //Target missing
                    CalculatorMappings_Internal.RemoveAt(i);
                    i--;
                }
            }

            //Restore instances
            this.Instances.ForEach(x => x.RestoreReferences(networkElements));

            //Assets
            assetManager.RestoreAssetsToComponent(this);

            //Parameters
            this.Parameters.ForEach(x => x.RestoreReferences(Factory.ProjectData.IdGenerator));

            //Call on child components
            foreach (var subComp in this.Components)
                subComp.RestoreReferences(networkElements, assetManager);
        }

        internal void RemoveAllAssets()
        {
            for (int i = 0; i < this.Instances.Count; ++i)
            {
                var instance = this.Instances[i];
                for (int j = 0; j < instance.Placements.Count; ++j)
                {
                    if (instance.Placements[j] is SimInstancePlacementGeometry)
                        this.Instances.RemoveAt(j);
                }

                if (instance.Placements.Count == 0)
                    this.Instances.RemoveAt(i);
            }

            foreach (var asset in this.ReferencedAssets)
                asset.RemoveReferencing(this.Id.LocalId);
            this.ReferencedAssets_Internal.Clear();

            foreach (var child in this.Components.Where(x => x.Component != null))
                child.Component.RemoveAllAssets();
        }




        /// <summary>
        /// Executes all calculations in this component and in it's subcomponents in the correct order.
        /// Executes subcomponent calculations first, then calculations in the current component.
        /// </summary>
        /// <param name="tableNameProvider">A method which returns the name of newly created <see cref="SimMultiValueBigTable"/>s during
        /// a vector calculation. May be used to localize table names.</param>
        /// <param name="tableNameAverageProvider">A method which returns the name of newly created <see cref="SimMultiValueBigTable"/>s during
        /// the averaging of vector calculation results. May be used to localize table names.</param>
        /// <param name="parameterReplacements">A list of parameters which override the parameters used by default</param>
        /// <param name="valueFields">The value manager for executing vector calculations</param>
        /// <param name="dispatcher">The dispatcher in which UI operations should be performed</param>
        public void ExecuteAllCalculationChains(
            TableNameProviderDelegate tableNameProvider = null, TableNameProviderDelegate tableNameAverageProvider = null,
            Dictionary<SimDoubleParameter, SimDoubleParameter> parameterReplacements = null,
            SimMultiValueCollection valueFields = null, Dispatcher dispatcher = null)
        {
            foreach (var entry in this.Components)
            {
                SimComponent sC = entry.Component;
                if (sC != null)
                    sC.ExecuteAllCalculationChains(tableNameProvider, tableNameAverageProvider, parameterReplacements, valueFields, dispatcher);
            }

            // perform the calculations
            foreach (SimCalculation c in this.Calculations)
            {
                c.Calculate(valueFields,
                    tableNameProvider, tableNameAverageProvider,
                    parameterReplacements, dispatcher);
            }
        }
    }
}
