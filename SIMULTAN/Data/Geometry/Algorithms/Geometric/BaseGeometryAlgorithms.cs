using SIMULTAN;
using SIMULTAN.Projects;
using SIMULTAN.Utils;
using System;
using System.Collections.Generic;
using System.Linq;

namespace SIMULTAN.Data.Geometry
{
    /// <summary>
    /// Provides methods that operate on BaseGeometries (on all types of Geometry)
    /// </summary>
    public static class BaseGeometryAlgorithms
    {
        /// <summary>
        /// Returns a list of all vertices in a Geometry. Only supports Vertex, Edge, Face, Volume
        /// </summary>
        /// <param name="geometry">The geometry for which the vertices should be returned</param>
        /// <returns>A list of all vertices in hte geometry</returns>
        public static List<Vertex> GetVertices(BaseGeometry geometry)
        {
            if (geometry is Vertex)
                return new List<Vertex> { geometry as Vertex };
            else if (geometry is Edge)
                return ((Edge)geometry).Vertices.ToList();
            else if (geometry is Face)
                return ((Face)geometry).Boundary.Edges.Select(x => x.StartVertex).ToList();
            else if (geometry is Volume)
                return VerticesFromVolume(geometry as Volume);

            return new List<Vertex>();
        }

        private static List<Vertex> VerticesFromVolume(Volume volume)
        {
            List<Vertex> result = new List<Vertex>();

            foreach (var f in volume.Faces)
            {
                result.AddRange(f.Face.Boundary.Edges.Select(x => x.StartVertex));
            }

            return result.Distinct().ToList();
        }

        /// <summary>
        /// Cleanly removes the given geometries. Model of the geometries have to be loaded.
        /// Removes all given geometry and resulting unreferenced geometry.
        /// Also removes all relations that are not autogenerated.
        /// </summary>
        /// <param name="projectData">The project data containing all the loaded models.</param>
        /// <param name="geometries">The geometries to cleanly remove</param>
        public static void RemoveGeometryClean(ProjectData projectData, IEnumerable<BaseGeometry> geometries)
        {
            List<BaseGeometry> initialDeleteGeometry = new List<BaseGeometry>();
            List<BaseGeometry> unreferencedSourceGeometry = new List<BaseGeometry>();

            foreach (var geo in geometries)
            {
                if (geo is ProxyGeometry)
                {
                    continue;
                }
                if (geo.ModelGeometry.Model.Permissions.GeometryPermissions.HasFlag(GeometryOperationPermissions.Delete))
                {
                    if (geo is Vertex vertex)
                    {
                        foreach (var proxy in vertex.ProxyGeometries)
                        {
                            initialDeleteGeometry.Add(proxy);
                            unreferencedSourceGeometry.Add(proxy);
                        }

                    }
                    // gets deleted and is therefore also unreferenced.
                    initialDeleteGeometry.Add(geo);
                    unreferencedSourceGeometry.Add(geo);
                }
            }

            if (initialDeleteGeometry.Count == 0)
                return;

            // keep track of all the relations that need to be removed, separately for unreferenced geometry
            HashSet<SimGeometryRelation> relationsToRemove = new HashSet<SimGeometryRelation>();
            HashSet<SimGeometryRelation> relationsToRemoveUnref = new HashSet<SimGeometryRelation>();

            foreach (var model in initialDeleteGeometry.Select(x => x.ModelGeometry).Distinct().ToList())
            {
                model.StartBatchOperation();

                //Step 1: Delete all geometry that necessarily has to be removed
                var deleteGeometry = initialDeleteGeometry.Where(x => x.ModelGeometry == model).ToList();
                var deleteGeometryLookup = new HashSet<BaseGeometry>(deleteGeometry);

                for (int i = 0; i < deleteGeometry.Count; ++i)
                {
                    var geom = deleteGeometry[i];
                    geom.RemoveFromModel();

                    if (geom is Vertex v)
                    {
                        foreach (var edge in v.Edges)
                        {
                            if (!deleteGeometryLookup.Contains(edge))
                            {
                                deleteGeometry.Add(edge);
                                deleteGeometryLookup.Add(edge);
                            }
                        }
                    }
                    else if (geom is Edge e)
                    {
                        foreach (var parent in e.PEdges.Select(x => x.Parent))
                        {
                            if (!deleteGeometryLookup.Contains(parent))
                            {
                                deleteGeometry.Add(parent);
                                deleteGeometryLookup.Add(parent);
                            }
                        }
                    }
                    else if (geom is EdgeLoop l)
                    {
                        foreach (var f in l.Faces)
                        {
                            if (f.Boundary == l) //Boundary -> delete face
                            {
                                if (!deleteGeometryLookup.Contains(f))
                                {
                                    deleteGeometry.Add(f);
                                    deleteGeometryLookup.Add(f);
                                }
                            }
                            else //Opening -> remove opening
                            {
                                if (!deleteGeometryLookup.Contains(f))
                                {
                                    //Remove opening
                                    f.Holes.Remove(l);
                                }
                            }
                        }
                    }
                    else if (geom is Polyline)
                    {
                        //Nothing required
                    }
                    else if (geom is Face f)
                    {
                        foreach (var volume in f.PFaces.Select(x => x.Volume))
                        {
                            if (!deleteGeometryLookup.Contains(volume))
                            {
                                deleteGeometry.Add(volume);
                                deleteGeometryLookup.Add(volume);
                            }
                        }

                        if (!deleteGeometryLookup.Contains(f.Boundary) && !f.Boundary.Faces.Exists(hf => !deleteGeometryLookup.Contains(hf)))
                        {
                            deleteGeometry.Add(f.Boundary);
                            deleteGeometryLookup.Add(f.Boundary);
                        }

                        foreach (var hole in f.Holes)
                        {
                            if (!hole.Faces.Exists(hf => !deleteGeometryLookup.Contains(hf)) && !deleteGeometryLookup.Contains(hole))
                            {
                                deleteGeometry.Add(hole);
                                deleteGeometryLookup.Add(hole);
                                unreferencedSourceGeometry.Add(hole);
                            }
                        }
                    }
                }


                // find their non auto-generated relations
                foreach (var geo in deleteGeometry)
                {
                    var relations = projectData.GeometryRelations.GetRelationsOf(geo).Where(x => !x.IsAutogenerated);
                    relations.ForEach(x => relationsToRemove.Add(x));
                }


                //Step 1.1 Remove GeoReferences where the target geometry is deleted
                model.GeoReferences.RemoveWhere(x => deleteGeometry.Contains(x.Vertex));

                //Step 2: Remove all unreferenced geometries
                List<BaseGeometry> unreferencedDelete = new List<BaseGeometry>();

                for (int i = 0; i < unreferencedSourceGeometry.Count; ++i)
                {
                    var geom = unreferencedSourceGeometry[i];
                    geom.RemoveFromModel();

                    if (geom is Edge e)
                    {
                        foreach (var v in e.Vertices)
                        {
                            if (!deleteGeometryLookup.Contains(v) && !v.Edges.Exists(x => !deleteGeometryLookup.Contains(x))
                                && v.ProxyGeometries.Count == 0)
                            {
                                unreferencedSourceGeometry.Add(v);
                                deleteGeometryLookup.Add(v);
                                unreferencedDelete.Add(v);
                            }
                        }
                    }
                    else if (geom is Polyline pl)
                    {
                        foreach (var edge in pl.Edges.Select(x => x.Edge))
                        {
                            if (!deleteGeometryLookup.Contains(edge) && !edge.PEdges.Exists(x => !deleteGeometryLookup.Contains(x.Parent)))
                            {
                                unreferencedSourceGeometry.Add(edge);
                                deleteGeometryLookup.Add(edge);
                                unreferencedDelete.Add(edge);
                            }
                        }
                    }
                    else if (geom is EdgeLoop l)
                    {
                        foreach (var f in l.Faces.Where(x => x.Boundary != l)) //Holes
                        {
                            f.Holes.Remove(l);
                        }

                        foreach (var edge in l.Edges.Select(x => x.Edge))
                        {
                            if (!deleteGeometryLookup.Contains(edge) && !edge.PEdges.Exists(x => !deleteGeometryLookup.Contains(x.Parent)))
                            {
                                unreferencedSourceGeometry.Add(edge);
                                deleteGeometryLookup.Add(edge);
                                unreferencedDelete.Add(edge);
                            }
                        }
                    }
                    else if (geom is Face f)
                    {
                        if (!deleteGeometryLookup.Contains(f.Boundary))
                        {
                            deleteGeometryLookup.Add(f.Boundary);
                            unreferencedDelete.Add(f.Boundary);
                        }
                        unreferencedSourceGeometry.Add(f.Boundary); //Add always to delete unreferenced edges

                        //Special case: Also delete unassociated hole faces
                        foreach (var hole in f.Holes)
                        {
                            //Add hole faces if they are not referenced by anyone else
                            foreach (var holeFace in hole.Faces.Where(x => x.Boundary == hole))
                            {
                                if (!deleteGeometryLookup.Contains(holeFace) && holeFace.PFaces.Count == 0)
                                {
                                    unreferencedDelete.Add(holeFace);
                                    deleteGeometryLookup.Add(holeFace);
                                    unreferencedSourceGeometry.Add(holeFace);
                                }
                            }

                            if (!hole.Faces.Exists(hf => !deleteGeometryLookup.Contains(hf)))
                            {
                                if (!deleteGeometryLookup.Contains(hole))
                                {
                                    deleteGeometryLookup.Add(hole);
                                    unreferencedDelete.Add(hole);
                                }

                                unreferencedSourceGeometry.Add(hole);

                                foreach (var hf in hole.Faces)
                                {
                                    if (!deleteGeometryLookup.Contains(hf))
                                    {
                                        deleteGeometryLookup.Add(hf);
                                        unreferencedDelete.Add(hf);
                                    }

                                    unreferencedSourceGeometry.Add(hf);
                                }
                            }
                        }
                    }
                    else if (geom is Volume v)
                    {
                        foreach (var face in v.Faces.Select(x => x.Face))
                        {
                            if (!deleteGeometryLookup.Contains(face) && !face.PFaces.Exists(pf => !deleteGeometryLookup.Contains(pf.Volume)))
                            {
                                unreferencedSourceGeometry.Add(face);
                                deleteGeometryLookup.Add(face);
                                unreferencedDelete.Add(face);
                            }
                        }
                    }
                }

                foreach (var geo in unreferencedDelete)
                {
                    var relations = projectData.GeometryRelations.GetRelationsOf(geo).Where(x => !x.IsAutogenerated);
                    foreach (var rel in relations)
                    {
                        if (!relationsToRemove.Contains(rel))
                            relationsToRemoveUnref.Add(rel);
                    }
                }

                //Step 2.1 Remove GeoReferences where the target geometry is unreferenced deleted
                model.GeoReferences.RemoveWhere(x => unreferencedDelete.Contains(x.Vertex));

                model.EndBatchOperation();
            }

            // remove relations
            relationsToRemove.ForEach(x => projectData.GeometryRelations.Remove(x));
            relationsToRemoveUnref.ForEach(x => projectData.GeometryRelations.Remove(x));
        }
    }
}
